<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>MemoWindow - Create Beautiful Waveform Memories</title>
  <meta name="description" content="Transform precious voice recordings into beautiful waveform art and create lasting visual memories">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="MemoWindow">
  
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- Apple Touch Icons -->
  <link rel="apple-touch-icon" href="images/icon-192.png">
  
  <style>
    /* Modern Clean Design System */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      background: #f8fafc;
      overflow-x: hidden;
    }
    
    /* Modern Header */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      z-index: 1000;
      padding: 1rem 0;
    }
    
    .nav {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      text-decoration: none;
      color: #333;
      font-weight: 600;
      font-size: 1.25rem;
    }
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid #667eea;
    }
    
    .header-link {
      color: #000;
      text-decoration: none;
      font-weight: bold;
      font-size: 0.9rem;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      transition: all 0.3s ease;
    }
    
    .header-link:hover {
      background: rgba(0, 0, 0, 0.1);
      color: #333;
    }
    
    /* Main Content */
    .wrap {
      padding: 4rem 1rem;
      max-width: 1200px;
      margin: 0 auto;
      margin-top: 170px;
    }
    
    .card {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.05);
      transition: transform 0.3s, box-shadow 0.3s;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
    }
    
    .card-header {
      margin-bottom: 1.5rem;
    }
    
    .card-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 0.5rem;
    }
    
    .card-subtitle {
      color: #6b7280;
      font-size: 1rem;
      line-height: 1.5;
    }
    
    .form-group {
      margin-bottom: 1.5rem;
    }
    
    .form-input {
      width: 100%;
      padding: 0.75rem 1rem;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 1rem;
      transition: border-color 0.3s, box-shadow 0.3s;
      background: white;
      color: #000;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .form-input::placeholder {
      color: #6b7280;
    }
    
    .upload-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .divider-section {
      text-align: center;
      position: relative;
    }
    
    .divider-text {
      color: #6b7280;
      font-size: 14px;
      font-weight: 500;
      background: white;
      padding: 0 1rem;
      position: relative;
      z-index: 1;
    }
    
    .divider-section::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background: #e5e7eb;
      z-index: 0;
    }
    
    .record-button {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      border: none;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
      align-self: center;
    }
    
    .record-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
      background: linear-gradient(135deg, #dc2626, #b91c1c);
    }
    
    .record-button:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
    }
    
    .waveform-link {
      transition: color 0.2s ease, opacity 0.2s ease;
    }
    
    .waveform-link:hover {
      opacity: 0.7;
    }
    
    /* File upload area */
    .file-upload-area {
      width: 100%;
      justify-content: center;
      padding: 32px;
      min-height: 100px;
      margin: 2rem 0;
      border: 2px dashed #d1d5db;
      border-radius: 12px;
      background: #f9fafb;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .file-upload-area:hover {
      border-color: #667eea;
      background: #f0f4ff;
    }
    
    .file-upload-area.has-files {
      border-color: #10b981;
      background: #ecfdf5;
      border-style: solid;
    }
    
    .file-upload-icon {
      color: #6b7280;
      transition: color 0.3s ease;
    }
    
    .file-upload-area.has-files .file-upload-icon {
      color: #10b981;
    }
    
    .file-upload-text {
      color: #6b7280;
      font-weight: 500;
      transition: color 0.3s ease;
    }
    
    .file-upload-area.has-files .file-upload-text {
      color: #10b981;
      font-weight: 600;
    }
    
    /* Button System */
    button {
      min-height: 44px;
      border: none;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      text-decoration: none;
      font-size: 1rem;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 0.75rem 1.5rem;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    }
    
    .btn-primary:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .btn-danger {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      padding: 0.75rem 1.5rem;
    }
    
    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
    }
    
    .btn-full {
      width: 100%;
    }
    
    /* Hidden class */
    .hidden {
      display: none !important;
    }
    
    /* Responsive Design */
    @media (max-width: 767px) {
      .header {
        padding: 0.75rem 0;
      }
      
      .nav {
        padding: 0 0.75rem;
      }
      
      .wrap {
        padding: 2rem 0.75rem;
        margin-top: 120px;
      }
      
      .card {
        padding: 1.5rem;
        margin-bottom: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <!-- Modern Header -->
  <header class="header">
    <nav class="nav">
      <a href="index.html" class="logo">
        <img src="images/logo.png" alt="MemoWindow" style="height: 40px; width: auto;">
      </a>
      <div id="userInfo" class="user-info hidden">
        <img id="userAvatar" class="user-avatar" src="" alt="User avatar">
        <span id="userName">Loading...</span>
        <a href="memories.html" class="header-link">My Memories</a>
        <a id="ordersLink" href="#" class="header-link">My Orders</a>
        <a id="btnLogout" href="#" class="header-link">Sign Out</a>
      </div>
    </nav>
  </header>

  <!-- Main Application Content -->
  <div id="mainContent" class="wrap">
    <!-- Memory Title Card -->
    <div class="card" style="margin-top: 4rem;">
      <div class="card-header">
        <h2 class="card-title">Memory Title</h2>
        <p class="card-subtitle">Give your memory a meaningful name</p>
      </div>
      <div class="form-group">
        <input id="titleInput" type="text" class="form-input" placeholder="Memory title (e.g., 'Mom's Laughter', 'Dad's Bedtime Story')" required>
      </div>
    </div>

    <!-- Upload and Record Card -->
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Add Your Audio</h2>
        <p class="card-subtitle">Upload audio files or record your voice to create beautiful waveform art</p>
      </div>
      
      <!-- Memory Preview -->
      <div id="memoryPreview" class="card hidden" style="margin-bottom: 1.5rem; padding: 1rem; background: #f9fafb; border: 2px dashed #d1d5db; border-radius: 8px;">
        <h3 style="margin: 0 0 1rem 0; color: #1f2937; font-size: 1.1rem;">Memory Preview</h3>
        <canvas id="previewCanvas" width="400" height="200" style="max-width: 100%; height: auto; border: 1px solid #e5e7eb; border-radius: 4px; background: white;"></canvas>
        <p id="previewStatus" style="margin: 0.5rem 0 0 0; color: #6b7280; font-size: 0.9rem;">Upload audio files to see preview</p>
      </div>
      <div class="upload-section">
        <label for="file" class="file-upload-area" id="fileUploadArea" style="cursor: pointer; width: 100%;">
          <input id="file" type="file" accept="audio/*" multiple style="display: none;">
          <svg class="file-upload-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
            <path d="M12,11L16,15H13.5V19H10.5V15H8L12,11Z"/>
          </svg>
          <span class="file-upload-text" id="fileUploadText">Upload Audio Files</span>
        </label>
        
        <div class="divider-section">
          <span class="divider-text">or</span>
        </div>
        
        <button id="btnRecord" type="button" class="record-button" style="display: flex; align-items: center; justify-content: center;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z" />
          </svg>
        </button>
      </div>
      <div style="margin-top: 1.5rem; text-align: center;">
        <button id="btnCreate" class="btn btn-primary btn-full" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
            <path d="M12,11L16,15H13.5V19H10.5V15H8L12,11Z" />
          </svg>
          Create Memory
        </button>
      </div>
      <div style="margin-top: 8px;">
        <span id="status" class="muted" style="font-size: 14px; color: #6b7280;"></span>
      </div>
    </div>

    <!-- User's Waveforms List -->
    <div id="waveformsList" class="card hidden">
      <h3 style="margin: 0 0 16px 0; color: #0b0d12;">Your MemoWindows</h3>
      <div id="waveformsContainer">
        <div class="muted" style="text-align: center; padding: 20px;">Loading your MemoWindows...</div>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script type="module" src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script type="module" src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
  
  <!-- App Scripts -->
  <script type="module" src="src/app-auth.js"></script>
  <script type="module" src="src/storage.js"></script>
  <script type="module" src="src/globals.js"></script>
  <script type="module" src="src/utils.js"></script>
  
  <script type="module">
    // Import necessary modules
    import { initAppAuth, getCurrentUser } from './src/app-auth.js';
    import { uploadWaveformFiles } from './src/storage.js';
    import { showToast, showLoading, hideLoading, showConfirmDialog, handleError, formatFileSize, validateFileType, validateFileSize } from './src/utils.js';
    
    // Make functions available globally
    window.getCurrentUser = getCurrentUser;
    window.uploadWaveformFiles = uploadWaveformFiles;
    window.showToast = showToast;
    window.showLoading = showLoading;
    window.hideLoading = hideLoading;
    window.showConfirmDialog = showConfirmDialog;
    window.handleError = handleError;
    window.formatFileSize = formatFileSize;
    window.validateFileType = validateFileType;
    window.validateFileSize = validateFileSize;
    
    // Global variables
    let selectedFiles = [];
    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentPeaks = null;
    let previewCanvas = null;
    let previewCtx = null;
    
    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
      console.log('🚀 MemoWindow App Initializing...');
      initAppAuth();
      initializeApp();
    });
    
    function initializeApp() {
      console.log('🔧 Initializing app functionality...');
      
      // Get DOM elements
      const fileInput = document.getElementById('file');
      const fileUploadArea = document.getElementById('fileUploadArea');
      const fileUploadText = document.getElementById('fileUploadText');
      const btnRecord = document.getElementById('btnRecord');
      const btnCreate = document.getElementById('btnCreate');
      const titleInput = document.getElementById('titleInput');
      const status = document.getElementById('status');
      const memoryPreview = document.getElementById('memoryPreview');
      previewCanvas = document.getElementById('previewCanvas');
      
      if (!fileInput || !fileUploadArea || !btnRecord || !btnCreate) {
        console.error('❌ Required DOM elements not found');
        return;
      }
      
      // Set up preview canvas
      if (previewCanvas) {
        previewCtx = previewCanvas.getContext('2d');
        console.log('✅ Preview canvas initialized');
      }
      
      // File upload functionality
      fileInput.addEventListener('change', handleFileSelect);
      fileUploadArea.addEventListener('click', () => fileInput.click());
      fileUploadArea.addEventListener('dragover', handleDragOver);
      fileUploadArea.addEventListener('drop', handleFileDrop);
      
      // Record button functionality
      btnRecord.addEventListener('click', toggleRecording);
      
      // Create button functionality
      btnCreate.addEventListener('click', createMemory);
      
      // Title input validation
      titleInput.addEventListener('input', () => {
        validateForm();
        // Redraw preview when title changes
        if (currentPeaks) {
          drawPreview();
        }
      });
      
      console.log('✅ App functionality initialized');
    }
    
    async function processFileForPreview(audioFile) {
      const memoryPreview = document.getElementById('memoryPreview');
      const previewStatus = document.getElementById('previewStatus');
      
      if (!memoryPreview || !previewStatus) return;
      
      try {
        memoryPreview.classList.remove('hidden');
        previewStatus.textContent = 'Processing audio for preview...';
        
        // Decode the audio file
        const buf = await decode(audioFile);
        currentPeaks = computePeaksFromBuffer(buf, 2000);
        
        // Draw the preview
        drawPreview();
        
        previewStatus.textContent = `Preview ready - ${audioFile.name}`;
        
      } catch (error) {
        console.error('Preview processing error:', error);
        previewStatus.textContent = 'Error processing audio file';
      }
    }
    
    function drawPreview() {
      if (!currentPeaks || !previewCtx || !previewCanvas) return;
      
      const W = previewCanvas.width;
      const H = previewCanvas.height;
      
      // Clear canvas
      previewCtx.clearRect(0, 0, W, H);
      
      // Draw white background
      previewCtx.fillStyle = '#fff';
      previewCtx.fillRect(0, 0, W, H);
      
      // Get title from input
      const titleInput = document.getElementById('titleInput');
      const title = titleInput ? titleInput.value.trim() || 'Untitled Memory' : 'Untitled Memory';
      
      // Calculate layout areas
      const titleHeight = 30;
      const qrSize = 40;
      const padding = 15;
      const waveformWidth = W * 0.7;
      const waveformArea = {
        x: (W - waveformWidth) / 2,
        y: titleHeight + padding,
        width: waveformWidth,
        height: H - titleHeight - qrSize - (padding * 3)
      };
      
      // Draw title at top center
      previewCtx.fillStyle = '#0b0d12';
      previewCtx.font = 'bold 12px system-ui, -apple-system, sans-serif';
      previewCtx.textAlign = 'center';
      previewCtx.textBaseline = 'middle';
      
      // Word wrap title if too long
      const maxTitleWidth = W - (padding * 2);
      const words = title.split(' ');
      let line = '';
      let lines = [];
      
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = previewCtx.measureText(testLine);
        const testWidth = metrics.width;
        
        if (testWidth > maxTitleWidth && n > 0) {
          lines.push(line);
          line = words[n] + ' ';
        } else {
          line = testLine;
        }
      }
      lines.push(line);
      
      // Draw title lines
      const lineHeight = 15;
      const titleStartY = titleHeight / 2 - ((lines.length - 1) * lineHeight / 2);
      lines.forEach((line, index) => {
        previewCtx.fillText(line.trim(), W / 2, titleStartY + (index * lineHeight));
      });
      
      // Draw waveform in center area
      previewCtx.fillStyle = '#000';
      const waveformPad = waveformArea.height * 0.1;
      function yMap(v) { 
        return waveformArea.y + waveformArea.height - waveformPad - (v + 1) / 2 * (waveformArea.height - 2 * waveformPad); 
      }
      
      for (let x = 0; x < waveformArea.width; x++) {
        const i = Math.floor(x * currentPeaks.min.length / waveformArea.width);
        const y1 = yMap(currentPeaks.max[i]);
        const y2 = yMap(currentPeaks.min[i]);
        const lineWidth = Math.max(1, Math.floor(waveformArea.width / 800));
        previewCtx.fillRect(waveformArea.x + x, y1, lineWidth, Math.max(1, y2 - y1));
      }
      
      // Add QR code placeholder
      drawQRPlaceholder(previewCtx, padding, H - qrSize - padding, qrSize);
    }
    
    function handleFileSelect(event) {
      const files = Array.from(event.target.files);
      processFiles(files);
    }
    
    function handleDragOver(event) {
      event.preventDefault();
      event.currentTarget.style.background = '#f0f4ff';
    }
    
    function handleFileDrop(event) {
      event.preventDefault();
      event.currentTarget.style.background = '';
      const files = Array.from(event.dataTransfer.files);
      processFiles(files);
    }
    
    function processFiles(files) {
      const audioFiles = files.filter(file => file.type.startsWith('audio/'));
      
      if (audioFiles.length === 0) {
        showToast('Please select audio files only', 'warning');
        return;
      }
      
      // Validate file sizes (max 50MB per file)
      const maxSize = 50 * 1024 * 1024; // 50MB
      const invalidFiles = audioFiles.filter(file => !validateFileSize(file, maxSize));
      
      if (invalidFiles.length > 0) {
        showToast(`Some files are too large. Maximum size is ${formatFileSize(maxSize)}`, 'error');
        return;
      }
      
      selectedFiles = [...selectedFiles, ...audioFiles];
      updateFileDisplay();
      validateForm();
      
      // Process the first file for preview
      if (audioFiles.length > 0) {
        processFileForPreview(audioFiles[0]);
      }
    }
    
    function updateFileDisplay() {
      const fileUploadText = document.getElementById('fileUploadText');
      const fileUploadArea = document.getElementById('fileUploadArea');
      
      if (selectedFiles.length === 0) {
        fileUploadText.textContent = 'Upload Audio Files';
        fileUploadArea.classList.remove('has-files');
      } else if (selectedFiles.length === 1) {
        fileUploadText.textContent = selectedFiles[0].name;
        fileUploadArea.classList.add('has-files');
      } else {
        fileUploadText.textContent = `${selectedFiles.length} files selected`;
        fileUploadArea.classList.add('has-files');
      }
    }
    
    async function toggleRecording() {
      const btnRecord = document.getElementById('btnRecord');
      const status = document.getElementById('status');
      
      if (!isRecording) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          recordedChunks = [];
          
          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const fileName = `recording_${Date.now()}.webm`;
            const file = new File([blob], fileName, { type: 'audio/webm' });
            selectedFiles.push(file);
            updateFileDisplay();
            validateForm();
            
            // Stop all tracks
            stream.getTracks().forEach(track => track.stop());
          };
          
          mediaRecorder.start();
          isRecording = true;
          btnRecord.style.background = 'linear-gradient(135deg, #dc2626, #b91c1c)';
          status.textContent = 'Recording... Click to stop';
          showToast('Recording started', 'info');
          
        } catch (error) {
          console.error('Recording error:', error);
          showToast('Unable to access microphone. Please check permissions.', 'error');
        }
      } else {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
        isRecording = false;
        btnRecord.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
        status.textContent = '';
        showToast('Recording saved', 'success');
      }
    }
    
    function validateForm() {
      const titleInput = document.getElementById('titleInput');
      const btnCreate = document.getElementById('btnCreate');
      
      const hasTitle = titleInput.value.trim().length > 0;
      const hasFiles = selectedFiles.length > 0;
      
      btnCreate.disabled = !(hasTitle && hasFiles);
    }
    
    async function createMemory() {
      const titleInput = document.getElementById('titleInput');
      const btnCreate = document.getElementById('btnCreate');
      const status = document.getElementById('status');
      
      const title = titleInput.value.trim();
      if (!title || selectedFiles.length === 0) {
        showToast('Please enter a title and select audio files', 'warning');
        return;
      }
      
      showLoading(btnCreate, 'Creating Memory...');
      status.textContent = 'Processing your memory...';
      
      try {
        const currentUser = getCurrentUser();
        if (!currentUser) {
          throw new Error('Not authenticated');
        }
        
        // Process each audio file
        for (let i = 0; i < selectedFiles.length; i++) {
          const file = selectedFiles[i];
          status.textContent = `Processing ${i + 1} of ${selectedFiles.length}: ${file.name}`;
          
          // Create waveform from audio file
          const waveformBlob = await createWaveformFromAudio(file);
          
          // Upload files
          const uploadResult = await uploadWaveformFiles(
            waveformBlob,
            file.name,
            currentUser.uid,
            file
          );
          
          if (!uploadResult.success) {
            throw new Error(uploadResult.error || 'Upload failed');
          }
          
          // Save to database
          const saveResult = await saveMemoryToDatabase({
            title: title,
            user_id: currentUser.uid,
            image_url: uploadResult.waveformUrl,
            qr_url: uploadResult.qrUrl,
            audio_url: uploadResult.audioUrl,
            original_name: file.name,
            play_page_url: uploadResult.playPageUrl
          });
          
          if (!saveResult.success) {
            throw new Error(saveResult.error || 'Database save failed');
          }
        }
        
        showToast(`Successfully created ${selectedFiles.length} memory(ies)!`, 'success');
        
        // Reset form
        titleInput.value = '';
        selectedFiles = [];
        currentPeaks = null;
        updateFileDisplay();
        validateForm();
        status.textContent = '';
        
        // Clear file input
        const fileInput = document.getElementById('file');
        if (fileInput) {
          fileInput.value = '';
        }
        
        // Hide preview
        const memoryPreview = document.getElementById('memoryPreview');
        if (memoryPreview) {
          memoryPreview.classList.add('hidden');
        }
        
        // Redirect to memories page
        setTimeout(() => {
          window.location.href = 'memories.html';
        }, 1500); // Small delay to show success message
        
      } catch (error) {
        console.error('Create memory error:', error);
        handleError(error, 'Create Memory');
        status.textContent = '';
      } finally {
        hideLoading(btnCreate);
      }
    }
    
    // Original waveform creation functions from the backup
    async function decode(file) {
      const arrayBuf = await file.arrayBuffer();
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return await audioCtx.decodeAudioData(arrayBuf);
    }

    function computePeaksFromBuffer(buf, width = 2000) {
      const ch = buf.getChannelData(0);
      const hop = Math.max(1, Math.floor(buf.length / width));
      const min = new Float32Array(width), max = new Float32Array(width);
      for (let x = 0; x < width; x++) {
        const s = x * hop, e = Math.min((x + 1) * hop, buf.length);
        let mi = 1.0, ma = -1.0;
        for (let i = s; i < e; i++) { 
          const v = ch[i]; 
          if (v < mi) mi = v; 
          if (v > ma) ma = v; 
        }
        min[x] = mi; 
        max[x] = ma;
      }
      return { min, max };
    }

    async function createWaveformFromAudio(audioFile) {
      return new Promise(async (resolve, reject) => {
        try {
          console.log('🎵 Creating waveform from audio file:', audioFile.name);
          
          // Decode the audio file
          const buf = await decode(audioFile);
          const peaks = computePeaksFromBuffer(buf, 2000);
          
          // Create canvas for waveform
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas dimensions
          const W = 800;
          const H = 200;
          canvas.width = W;
          canvas.height = H;
          
          // Draw white background
          ctx.fillStyle = '#fff';
          ctx.fillRect(0, 0, W, H);
          
          // Get title from input
          const titleInput = document.getElementById('titleInput');
          const title = titleInput ? titleInput.value.trim() || 'Untitled Memory' : 'Untitled Memory';
          
          // Calculate layout areas
          const titleHeight = 40;
          const qrSize = 60;
          const padding = 20;
          const waveformWidth = W * 0.7;
          const waveformArea = {
            x: (W - waveformWidth) / 2,
            y: titleHeight + padding,
            width: waveformWidth,
            height: H - titleHeight - qrSize - (padding * 3)
          };
          
          // Draw title at top center
          ctx.fillStyle = '#0b0d12';
          ctx.font = 'bold 16px system-ui, -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Word wrap title if too long
          const maxTitleWidth = W - (padding * 2);
          const words = title.split(' ');
          let line = '';
          let lines = [];
          
          for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            
            if (testWidth > maxTitleWidth && n > 0) {
              lines.push(line);
              line = words[n] + ' ';
            } else {
              line = testLine;
            }
          }
          lines.push(line);
          
          // Draw title lines
          const lineHeight = 20;
          const titleStartY = titleHeight / 2 - ((lines.length - 1) * lineHeight / 2);
          lines.forEach((line, index) => {
            ctx.fillText(line.trim(), W / 2, titleStartY + (index * lineHeight));
          });
          
          // Draw waveform in center area
          ctx.fillStyle = '#000';
          const waveformPad = waveformArea.height * 0.1;
          function yMap(v) { 
            return waveformArea.y + waveformArea.height - waveformPad - (v + 1) / 2 * (waveformArea.height - 2 * waveformPad); 
          }
          
          for (let x = 0; x < waveformArea.width; x++) {
            const i = Math.floor(x * peaks.min.length / waveformArea.width);
            const y1 = yMap(peaks.max[i]);
            const y2 = yMap(peaks.min[i]);
            const lineWidth = Math.max(1, Math.floor(waveformArea.width / 800));
            ctx.fillRect(waveformArea.x + x, y1, lineWidth, Math.max(1, y2 - y1));
          }
          
          // Add QR code placeholder
          drawQRPlaceholder(ctx, padding, H - qrSize - padding, qrSize);
          
          // Convert to blob
          canvas.toBlob((blob) => {
            if (blob) {
              console.log('✅ Waveform created successfully');
              resolve(blob);
            } else {
              reject(new Error('Failed to create waveform blob'));
            }
          }, 'image/png');
          
        } catch (error) {
          console.error('Waveform creation error:', error);
          reject(error);
        }
      });
    }

    function drawQRPlaceholder(ctx, x, y, size) {
      // Draw QR placeholder
      ctx.fillStyle = '#f3f4f6';
      ctx.fillRect(x, y, size, size);
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, size, size);
      
      // QR placeholder text
      ctx.fillStyle = '#6b7280';
      ctx.font = '8px system-ui, -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('QR Code', x + size/2, y + size/2 - 4);
      ctx.fillText('(Generated)', x + size/2, y + size/2 + 4);
    }
    
    async function saveMemoryToDatabase(memoryData) {
      try {
        // Convert to form data since upload.php expects $_POST
        const formData = new FormData();
        formData.append('user_id', memoryData.user_id);
        formData.append('title', memoryData.title);
        formData.append('image_url', memoryData.image_url);
        formData.append('qr_url', memoryData.qr_url);
        formData.append('audio_url', memoryData.audio_url || '');
        formData.append('original_name', memoryData.original_name);
        formData.append('play_url', memoryData.play_page_url || '');
        
        const response = await fetch('upload.php', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Upload response error:', errorText);
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        return result;
        
      } catch (error) {
        console.error('Database save error:', error);
        return { success: false, error: error.message };
      }
    }
  </script>
</body>
</html>
