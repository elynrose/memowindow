<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Test - MemoWindow</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f8fafc;
        }
        .test-section {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin: 8px 0;
        }
        button:hover { background: #2563eb; }
        .result {
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
            font-family: monospace;
        }
        .success { background: #f0fdf4; color: #166534; border: 1px solid #bbf7d0; }
        .error { background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; }
        .info { background: #eff6ff; color: #1d4ed8; border: 1px solid #dbeafe; }
        input, textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            margin: 8px 0;
            font-family: inherit;
        }
        canvas {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            max-width: 100%;
            margin: 16px 0;
        }
    </style>
</head>
<body>
    <h1>üîß MemoWindow Upload Diagnostic Tool</h1>
    
    <div class="test-section">
        <h2>1. Basic Connection Tests</h2>
        <button onclick="testConnections()">Test API Endpoints</button>
        <div id="connectionResults"></div>
    </div>

    <div class="test-section">
        <h2>2. Audio File Processing</h2>
        <input type="file" id="audioFile" accept="audio/*" onchange="testAudioProcessing()">
        <div id="audioResults"></div>
        <canvas id="testCanvas" width="400" height="200" style="display:none;"></canvas>
    </div>

    <div class="test-section">
        <h2>3. Waveform Generation</h2>
        <button onclick="testWaveformGeneration()" id="waveformBtn" disabled>Generate Test Waveform</button>
        <div id="waveformResults"></div>
        <canvas id="waveformCanvas" width="600" height="300"></canvas>
    </div>

    <div class="test-section">
        <h2>4. Storage Upload Test</h2>
        <input type="text" id="testTitle" placeholder="Memory Title" value="Test Memory">
        <button onclick="testUpload()" id="uploadBtn" disabled>Test Full Upload Process</button>
        <div id="uploadResults"></div>
    </div>

    <script type="module">
        let currentAudioFile = null;
        let currentWaveform = null;

        window.testConnections = testConnections;
        window.testAudioProcessing = testAudioProcessing;
        window.testWaveformGeneration = testWaveformGeneration;
        window.testUpload = testUpload;

        function log(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.textContent = message;
            container.appendChild(div);
            console.log(message);
        }

        async function testConnections() {
            const container = document.getElementById('connectionResults');
            container.innerHTML = '';

            log('connectionResults', 'Testing API endpoints...', 'info');

            // Test 1: Configuration endpoint
            try {
                const response = await fetch('get_base_url.php');
                const data = await response.json();
                log('connectionResults', `‚úÖ Base URL: ${data.base_url}`, 'success');
            } catch (error) {
                log('connectionResults', `‚ùå Base URL failed: ${error.message}`, 'error');
            }

            // Test 2: Subscription check
            try {
                const response = await fetch('check_subscription_simple.php?user_id=test-user');
                const data = await response.json();
                log('connectionResults', `‚úÖ Subscription check: ${data.success ? 'OK' : 'Failed'}`, data.success ? 'success' : 'error');
            } catch (error) {
                log('connectionResults', `‚ùå Subscription check failed: ${error.message}`, 'error');
            }

            // Test 3: Database connection
            try {
                const response = await fetch('get_waveforms.php?user_id=test-user&limit=1');
                const data = await response.json();
                log('connectionResults', `‚úÖ Database: Connected`, 'success');
            } catch (error) {
                log('connectionResults', `‚ùå Database failed: ${error.message}`, 'error');
            }

            // Test 4: Backup storage
            try {
                const response = await fetch('backup_storage.php?action=stats');
                const data = await response.json();
                log('connectionResults', `‚úÖ Backup storage: ${data.total_files || 0} files`, 'success');
            } catch (error) {
                log('connectionResults', `‚ùå Backup storage failed: ${error.message}`, 'error');
            }
        }

        async function testAudioProcessing() {
            const container = document.getElementById('audioResults');
            container.innerHTML = '';
            const fileInput = document.getElementById('audioFile');
            
            if (!fileInput.files[0]) {
                log('audioResults', '‚ö†Ô∏è Please select an audio file first', 'error');
                return;
            }

            currentAudioFile = fileInput.files[0];
            log('audioResults', `üìÅ Processing file: ${currentAudioFile.name} (${Math.round(currentAudioFile.size/1024)}KB)`, 'info');

            try {
                // Test audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                log('audioResults', `‚úÖ Audio context created (${audioContext.sampleRate}Hz)`, 'success');

                // Test file reading
                const arrayBuffer = await currentAudioFile.arrayBuffer();
                log('audioResults', `‚úÖ File read: ${arrayBuffer.byteLength} bytes`, 'success');

                // Test audio decoding
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                log('audioResults', `‚úÖ Audio decoded: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.numberOfChannels} channels`, 'success');

                // Test peak computation
                const startTime = performance.now();
                const peaks = computePeaksFromBuffer(audioBuffer, 1000);
                const endTime = performance.now();
                log('audioResults', `‚úÖ Peaks computed in ${(endTime - startTime).toFixed(2)}ms: ${peaks.min.length} points`, 'success');

                // Draw simple preview
                const canvas = document.getElementById('testCanvas');
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#3b82f6';
                const centerY = canvas.height / 2;
                
                for (let x = 0; x < canvas.width; x++) {
                    const i = Math.floor(x * peaks.min.length / canvas.width);
                    const y1 = centerY + peaks.max[i] * centerY * 0.8;
                    const y2 = centerY + peaks.min[i] * centerY * 0.8;
                    ctx.fillRect(x, Math.min(y1, y2), 1, Math.abs(y2 - y1) || 1);
                }
                
                canvas.style.display = 'block';
                log('audioResults', '‚úÖ Preview waveform rendered', 'success');

                // Enable next test
                document.getElementById('waveformBtn').disabled = false;

            } catch (error) {
                log('audioResults', `‚ùå Audio processing failed: ${error.message}`, 'error');
                console.error(error);
            }
        }

        function computePeaksFromBuffer(buf, width = 1000) {
            const channels = buf.numberOfChannels;
            let audioData;
            
            if (channels === 1) {
                audioData = buf.getChannelData(0);
            } else {
                const length = buf.length;
                audioData = new Float32Array(length);
                for (let i = 0; i < length; i++) {
                    let sum = 0;
                    for (let ch = 0; ch < channels; ch++) {
                        sum += buf.getChannelData(ch)[i];
                    }
                    audioData[i] = sum / channels;
                }
            }
            
            const hop = Math.max(1, Math.floor(buf.length / width));
            const min = new Float32Array(width);
            const max = new Float32Array(width);
            
            for (let x = 0; x < width; x++) {
                const start = x * hop;
                const end = Math.min((x + 1) * hop, buf.length);
                let minVal = 1.0;
                let maxVal = -1.0;
                
                for (let i = start; i < end; i++) {
                    const sample = audioData[i];
                    if (sample < minVal) minVal = sample;
                    if (sample > maxVal) maxVal = sample;
                }
                
                min[x] = minVal;
                max[x] = maxVal;
            }
            
            return { min, max, duration: buf.duration, channels };
        }

        async function testWaveformGeneration() {
            if (!currentAudioFile) {
                log('waveformResults', '‚ö†Ô∏è Please process an audio file first', 'error');
                return;
            }

            const container = document.getElementById('waveformResults');
            container.innerHTML = '';
            
            log('waveformResults', 'üé® Generating high-resolution waveform...', 'info');

            try {
                const startTime = performance.now();
                const blob = await createWaveformFromAudio(currentAudioFile);
                const endTime = performance.now();

                log('waveformResults', `‚úÖ Waveform generated in ${(endTime - startTime).toFixed(2)}ms`, 'success');
                log('waveformResults', `üìè Blob size: ${Math.round(blob.size/1024)}KB`, 'success');

                currentWaveform = blob;

                // Display preview
                const url = URL.createObjectURL(blob);
                const img = new Image();
                img.onload = () => {
                    const canvas = document.getElementById('waveformCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Scale image to fit canvas
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const width = img.width * scale;
                    const height = img.height * scale;
                    const x = (canvas.width - width) / 2;
                    const y = (canvas.height - height) / 2;
                    
                    ctx.fillStyle = '#f8fafc';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, x, y, width, height);
                    
                    URL.revokeObjectURL(url);
                };
                img.src = url;

                log('waveformResults', '‚úÖ Waveform preview displayed', 'success');
                document.getElementById('uploadBtn').disabled = false;

            } catch (error) {
                log('waveformResults', `‚ùå Waveform generation failed: ${error.message}`, 'error');
                console.error(error);
            }
        }

        async function createWaveformFromAudio(audioFile) {
            const arrayBuffer = await audioFile.arrayBuffer();
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Create canvas
            const W = 1200;  // Smaller size for testing
            const H = 800;
            const canvas = document.createElement('canvas');
            canvas.width = W;
            canvas.height = H;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, W, H);
            
            // Get title
            const title = document.getElementById('testTitle').value || 'Test Memory';
            
            // Draw title
            ctx.fillStyle = '#0b0d12';
            ctx.font = 'bold 48px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(title, W / 2, 80);
            
            // Compute peaks
            const peaks = computePeaksFromBuffer(audioBuffer, Math.floor(W * 0.8));
            
            // Draw waveform
            const waveformArea = {
                x: W * 0.15,
                y: 120,
                width: W * 0.7,
                height: H - 240
            };
            
            ctx.fillStyle = '#333333';
            const centerY = waveformArea.y + waveformArea.height / 2;
            
            for (let x = 0; x < waveformArea.width; x += 2) {
                const i = Math.floor(x * peaks.min.length / waveformArea.width);
                const y1 = centerY + peaks.max[i] * waveformArea.height * 0.4;
                const y2 = centerY + peaks.min[i] * waveformArea.height * 0.4;
                const height = Math.max(2, Math.abs(y2 - y1));
                ctx.fillRect(waveformArea.x + x, Math.min(y1, y2), 2, height);
            }
            
            return new Promise(resolve => {
                canvas.toBlob(resolve, 'image/png', 1.0);
            });
        }

        async function testUpload() {
            if (!currentWaveform) {
                log('uploadResults', '‚ö†Ô∏è Please generate a waveform first', 'error');
                return;
            }

            const container = document.getElementById('uploadResults');
            container.innerHTML = '';
            
            const title = document.getElementById('testTitle').value || 'Test Memory';
            const userId = 'test-user-' + Date.now();
            
            log('uploadResults', 'üì§ Testing full upload process...', 'info');

            try {
                // Step 1: Test storage upload (simplified)
                log('uploadResults', 'üîÑ Step 1: Testing storage upload...', 'info');
                
                // Since we can't easily test Firebase in this environment, simulate it
                const mockUrls = {
                    waveformUrl: 'https://example.com/waveform.png',
                    audioUrl: 'https://example.com/audio.mp3',
                    qrUrl: 'https://api.qrserver.com/v1/create-qr-code/?size=512x512&data=test'
                };
                
                log('uploadResults', '‚úÖ Step 1: Storage URLs generated', 'success');
                
                // Step 2: Test database save
                log('uploadResults', 'üîÑ Step 2: Testing database save...', 'info');
                
                const formData = new FormData();
                formData.append('title', title);
                formData.append('user_id', userId);
                formData.append('image_url', mockUrls.waveformUrl);
                formData.append('qr_url', mockUrls.qrUrl);
                formData.append('audio_url', mockUrls.audioUrl);
                formData.append('original_name', currentAudioFile ? currentAudioFile.name : 'test.wav');
                formData.append('play_url', `https://example.com/play.php?uid=test-123`);
                formData.append('unique_id', 'mw_test_' + Date.now());
                
                const response = await fetch('upload_simple.php', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    log('uploadResults', `‚úÖ Step 2: Database save successful (ID: ${result.id})`, 'success');
                    log('uploadResults', 'üéâ Full upload test completed successfully!', 'success');
                } else {
                    throw new Error(result.error || 'Database save failed');
                }
                
            } catch (error) {
                log('uploadResults', `‚ùå Upload test failed: ${error.message}`, 'error');
                console.error('Full error:', error);
                
                // Try to get more details
                try {
                    const responseText = await error.response?.text();
                    if (responseText) {
                        log('uploadResults', `üìù Response details: ${responseText}`, 'info');
                    }
                } catch (e) {
                    // Ignore
                }
            }
        }

        // Auto-run connection tests
        setTimeout(testConnections, 1000);
    </script>
</body>
</html>
