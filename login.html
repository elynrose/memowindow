<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MemoWindow - Create Beautiful Waveform Memories</title>
  <meta name="description" content="Transform precious voice recordings into beautiful waveform art and create lasting visual memories">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="MemoWindow">
  
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- Apple Touch Icons (optional - add these files if you have them) -->
  <link rel="apple-touch-icon" href="images/icon-192.png">
  
  <!-- Styles are now loaded from external CSS file -->
  <style>
    /* Modern Clean Design System - Based on Home Page Theme */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      background: #f8fafc;
      overflow-x: hidden;
    }
    
    /* Modern Header */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      z-index: 1000;
      padding: 1rem 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .nav {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      color: #667eea;
      text-decoration: none;
    }
    
    .logo img {
      height: 40px;
      width: auto;
    }
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid #667eea;
    }
    
    .header-link {
      color: #000;
      text-decoration: none;
      font-weight: bold;
      font-size: 0.9rem;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      transition: all 0.3s ease;
    }
    
    .header-link:hover {
      background: rgba(0, 0, 0, 0.1);
      color: #333;
    }
    
    /* Hero Section */
    .hero {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 6rem 0 4rem;
      text-align: center;
      margin-top: 80px;
      position: relative;
      overflow: hidden;
    }
    
    .hero::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="0.5" fill="white" opacity="0.1"/><circle cx="10" cy="60" r="0.5" fill="white" opacity="0.1"/><circle cx="90" cy="40" r="0.5" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
      opacity: 0.3;
    }
    
    .hero-content {
      max-width: 800px;
      margin: 0 auto;
      padding: 0 2rem;
      position: relative;
      z-index: 1;
    }
    
    .hero h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      line-height: 1.2;
    }
    
    .hero p {
      font-size: 1.1rem;
      opacity: 0.9;
      max-width: 600px;
      margin: 0 auto;
    }
    
    /* Mobile-first responsive design improvements */
    
    /* Main Content */
    .wrap {
      padding: 2rem 1rem;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* Cards */
    .card {
      background: white;
      border-radius: 16px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.05);
      transition: transform 0.3s, box-shadow 0.3s;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
    }
    
    /* Mobile header improvements */
    .row {
      flex-direction: column;
      align-items: stretch;
      gap: 16px;
    }
    
    /* Logo responsive */
    .row h1 img {
      width: 100%;
      max-width: 280px;
      height: auto;
    }
    
    /* User info responsive */
    .user-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      text-align: center;
    }
    
    .user-avatar {
      width: 40px;
      height: 40px;
    }
    
    /* File upload area responsive */
    .file-upload-area {
      width: 100%;
      justify-content: center;
      padding: 16px;
      min-height: 60px;
    }
    
    /* Consistent Button System */
    button {
      min-height: 44px; /* iOS touch target size */
      font-size: 16px; /* Prevent zoom on iOS */
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    /* Primary buttons */
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 20px;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
    }
    
    /* Secondary buttons */
    .btn-secondary {
      background: #6b7280;
      color: white;
      padding: 12px 20px;
    }
    
    .btn-secondary:hover {
      background: #4b5563;
    }
    
    /* Small buttons */
    .btn-sm {
      padding: 8px 16px;
      font-size: 14px;
    }
    
    /* Extra small buttons */
    .btn-xs {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 4px;
    }
    
    /* Success buttons */
    .btn-success {
      background: #10b981;
      color: white;
      padding: 12px 20px;
    }
    
    .btn-success:hover {
      background: #059669;
    }
    
    /* Danger buttons */
    .btn-danger {
      background: #dc3545;
      color: white;
      padding: 12px 20px;
    }
    
    .btn-danger:hover {
      background: #b91c1c;
    }
    
    /* Warning buttons */
    .btn-warning {
      background: #f59e0b;
      color: white;
      padding: 12px 20px;
    }
    
    .btn-warning:hover {
      background: #d97706;
    }
    
    /* Full width buttons */
    .btn-full {
      width: 100%;
    }
    
    /* Disabled state */
    button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    button:disabled:hover {
      background: #9ca3af;
    }
    
    /* Input responsive improvements */
    input[type="text"], input[type="email"], input[type="password"] {
      min-height: 44px;
      font-size: 16px; /* Prevent zoom on iOS */
      width: 100%;
      box-sizing: border-box;
    }
    
    /* Main creation row responsive */
    .card .row {
      flex-direction: column;
      gap: 12px;
    }
    
    .card .row > * {
      width: 100%;
      margin: 0;
    }
    
    /* Auth modal responsive */
    .auth-modal-content {
      margin: 20px;
      max-width: calc(100vw - 40px);
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }
    
    .auth-modal-content h1 img {
      width: 100%;
      max-width: 280px;
      height: auto;
    }
    
    /* Recorder modal responsive */
    .recorder-modal-content {
      margin: 20px;
      max-width: calc(100vw - 40px);
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }
    
    .recorder-controls {
      flex-direction: column;
      gap: 12px;
    }
    
    .record-btn {
      width: 100%;
      min-height: 60px;
      font-size: 18px;
    }
    
    /* Results responsive */
    .results-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    .products-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    /* Waveform preview responsive */
    #waveformPreview {
      width: 100%;
      height: auto;
      max-width: 100%;
    }
    
    /* Waveform list responsive */
    .waveform-item {
      flex-direction: column;
      align-items: stretch;
      gap: 12px;
    }
    
    .waveform-item > div:first-child {
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
    }
    
    .waveform-item > div:last-child {
      flex-direction: row;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    /* Mobile responsive design */
    @media (max-width: 767px) {
      .nav {
        padding: 0 1rem;
      }
      
      .hero {
        padding: 4rem 0 3rem;
      }
      
      .hero h1 {
        font-size: 2rem;
      }
      
      .hero p {
        font-size: 1rem;
      }
      
      .user-info {
        flex-direction: column;
        gap: 0.5rem;
      }
    }
    
    /* Tablet styles */
    @media (min-width: 768px) {
      .wrap {
        padding: 24px;
        max-width: 900px;
      }
      
      .row {
        flex-direction: row;
        align-items: center;
      }
      
      .user-info {
        flex-direction: row;
        text-align: left;
      }
      
      .card .row {
        flex-direction: row;
        align-items: center;
      }
      
      .card .row > * {
        width: auto;
      }
      
      .file-upload-area {
        width: auto;
        min-width: 200px;
      }
      
      .results-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .products-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .recorder-controls {
        flex-direction: row;
        justify-content: center;
      }
      
      .record-btn {
        width: auto;
        min-width: 60px;
      }
      
      .waveform-item > div:first-child {
        flex-direction: row;
        align-items: center;
      }
    }
    
    /* Desktop styles */
    @media (min-width: 1024px) {
      .products-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .auth-modal-content {
        margin: 40px;
        max-width: 500px;
      }
      
      .recorder-modal-content {
        margin: 40px;
        max-width: 600px;
      }
    }
    
    /* Large desktop styles */
    @media (min-width: 1200px) {
      .wrap {
        max-width: 1200px;
      }
    }
    
    /* Touch improvements */
    @media (hover: none) and (pointer: coarse) {
      button:hover {
        transform: none;
      }
      
      .file-upload-area:hover {
        border-color: #e6e9f2;
        background: #fafbfc;
      }
      
      .file-upload-area:active {
        border-color: #2a4df5;
        background: #f0f4ff;
      }
    }
    
    /* High DPI displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .user-avatar {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
    }
    
    /* Landscape mobile */
    @media (max-height: 500px) and (orientation: landscape) {
      .auth-modal-content,
      .recorder-modal-content {
        max-height: calc(100vh - 20px);
        margin: 10px;
      }
    }
    
    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    /* Multi-audio file styles */
    .audio-file-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      gap: 12px;
    }
    
    .audio-file-info {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      min-width: 0;
    }
    
    .audio-file-icon {
      width: 24px;
      height: 24px;
      color: #3b82f6;
      flex-shrink: 0;
    }
    
    .audio-file-details {
      flex: 1;
      min-width: 0;
    }
    
    .audio-file-name {
      font-weight: 500;
      color: #374151;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .audio-file-size {
      font-size: 12px;
      color: #6b7280;
      margin-top: 2px;
    }
    
    .audio-file-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    /* Audio file action buttons */
    .play-audio-btn {
      background: #10b981;
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
      min-height: 32px;
    }
    
    .play-audio-btn:hover {
      background: #059669;
    }
    
    .stop-audio-btn {
      background: #f59e0b;
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
      min-height: 32px;
    }
    
    .stop-audio-btn:hover {
      background: #d97706;
    }
    
    .remove-audio-btn {
      background: #dc3545;
      color: white;
      padding: 6px 8px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      min-height: 32px;
    }
    
    .remove-audio-btn:hover {
      background: #b91c1c;
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      .card {
        background: #1f2937;
        border-color: #374151;
        color: #f9fafb;
      }
      
      .file-upload-area {
        background: #374151;
        border-color: #4b5563;
        color: #f9fafb;
      }
      
      input[type="text"], input[type="email"], input[type="password"] {
        background: #374151;
        border-color: #4b5563;
        color: #f9fafb;
      }
      
      input[type="text"]::placeholder,
      input[type="email"]::placeholder,
      input[type="password"]::placeholder {
        color: #9ca3af;
      }
      
      .audio-file-item {
        background: #374151;
        border-color: #4b5563;
      }
      
      .audio-file-name {
        color: #f9fafb;
      }
      
      .audio-file-size {
        color: #9ca3af;
      }
    }
  </style>
</head>
<body>
<!-- Auth Modal (shown when not authenticated) -->
<div id="authModal" class="auth-modal hidden">
  <div class="auth-modal-content">
    <div style="text-align: center; margin-bottom: 16px;">
      <a href="index.html" style="color: #667eea; text-decoration: none; font-size: 14px;">‚Üê Back to Home</a>
    </div>
    <h1 style="margin: 0;"><img src="images/logo.png" alt="MemoWindow" style="width: 280px; height: 50px;"></h1>
    <p>Transform precious voice recordings of your loved ones into beautiful waveform art. Create lasting visual memories that you can frame, share, and treasure forever.</p>
    
    <!-- Email Login Form -->
    <div id="emailLoginForm">
      <div style="margin-bottom: 16px;">
        <input type="email" id="emailInput" placeholder="Email address" 
               style="width: 100%; padding: 12px; border: 1px solid #e6e9f2; border-radius: 8px; font-size: 14px; margin-bottom: 8px;">
        <input type="password" id="passwordInput" placeholder="Password" 
               style="width: 100%; padding: 12px; border: 1px solid #e6e9f2; border-radius: 8px; font-size: 14px;">
      </div>
      
      <div style="display: flex; gap: 8px; margin-bottom: 16px;">
        <button id="btnEmailLogin" class="btn-primary btn-full" style="flex: 1;">
          Sign In
        </button>
        <button id="btnEmailRegister" class="btn-secondary btn-full" style="flex: 1;">
          Register
        </button>
      </div>
      
      <div style="text-align: center; margin: 16px 0; color: #6b7280; font-size: 14px;">
        or
      </div>
    </div>
    
    <!-- Google Login Button -->
    <button id="btnLogin" class="btn-auth">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
      </svg>
      Sign in with Google
    </button>
  </div>
</div>

<!-- Voice Recorder Modal -->
<div id="recorderModal" class="recorder-modal hidden" style="display: none;">
  <div class="recorder-modal-content">
    <h2>üé§ Record Your Voice</h2>
    <p style="color: #6b7280; margin: 0 0 24px 0;">Record a precious voice memory to transform into a beautiful waveform</p>
    
    <div id="recordingStatus" style="margin: 16px 0; min-height: 24px;">
      <span style="color: #6b7280;">Click record to begin</span>
    </div>
    
    <div class="timer" id="recordingTimer">00:00</div>
    
    <div class="recorder-controls">
      <button id="startRecordBtn" class="record-btn record" title="Start Recording">
        ‚è∫Ô∏è
      </button>
      <button id="stopRecordBtn" class="record-btn stop" disabled title="Stop Recording">
        ‚èπÔ∏è
      </button>
      <button id="playRecordBtn" class="record-btn play" disabled title="Play Recording">
        ‚ñ∂Ô∏è
      </button>
    </div>
    
    <audio id="recordedAudio" class="audio-preview" controls style="display: none;"></audio>
    
    <div style="margin-top: 24px; display: flex; justify-content: center; gap: 12px;">
        <button id="useRecordingBtn" class="btn-success" disabled>
          Use This Recording
        </button>
        <button id="cancelRecordingBtn" class="btn-secondary">
          Cancel
        </button>
    </div>
  </div>
  </div>

  <!-- Modern Header -->
  <header class="header">
    <nav class="nav">
      <a href="index.html" class="logo">
        <img src="images/logo.png" alt="MemoWindow" style="height: 40px; width: auto;">
      </a>
      <div id="userInfo" class="user-info hidden">
        <img id="userAvatar" class="user-avatar" src="" alt="User avatar">
        <span id="userName">Loading...</span>
        <a id="ordersLink" href="#" class="header-link">My Orders</a>
        <a id="btnLogout" href="#" class="header-link">Sign Out</a>
      </div>
    </nav>
  </header>

  <!-- Hero Section -->
  <section class="hero">
    <div class="hero-content">
      <h1>Create Beautiful Waveform Memories</h1>
      <p>Transform precious voice recordings into stunning visual art that you can frame, share, and treasure forever.</p>
    </div>
  </section>

<div id="mainContent" class="wrap">

  <div class="card">
    <div class="row">
      <label for="file" class="file-upload-area" id="fileUploadArea" style="cursor: pointer;">
        <input id="file" type="file" accept="audio/*" multiple style="display: none;">
        <svg class="file-upload-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
          <path d="M12,11L16,15H13.5V19H10.5V15H8L12,11Z"/>
        </svg>
        <span class="file-upload-text" id="fileUploadText">Upload Audio Files</span>
      </label>
      <span style="color: #6b7280; font-size: 14px; margin: 0 8px;">or</span>
      <button id="btnRecord" type="button" class="btn-danger" style="display: flex; align-items: center; gap: 6px;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z" />
        </svg>
        Record Voice
      </button>
      <input id="titleInput" type="text" placeholder="Memory title (e.g., 'Mom's Laughter', 'Dad's Bedtime Story')" required style="flex: 1; padding: 8px; border: 1px solid #e6e9f2; border-radius: 6px; margin: 0 8px;">
      <button id="btnCreate" class="btn-primary" disabled style="display: flex; align-items: center; gap: 6px;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
          <path d="M12,11L16,15H13.5V19H10.5V15H8L12,11Z" />
        </svg>
        Create Memory
      </button>
    </div>
    <div style="margin-top: 8px;">
      <span id="status" class="muted" style="font-size: 14px; color: #6b7280;"></span>
    </div>
    
    <!-- Multi-audio file management -->
    <div id="audioFilesList" class="audio-files-list" style="display: none; margin-top: 16px;">
      <h4 style="margin: 0 0 12px 0; color: #374151; font-size: 14px; font-weight: 600;">Selected Audio Files:</h4>
      <div id="audioFilesContainer" style="display: flex; flex-direction: column; gap: 8px;">
        <!-- Audio files will be dynamically added here -->
      </div>
      <div style="margin-top: 12px; padding: 12px; background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; font-size: 13px; color: #0c4a6e;">
        <strong>üéµ Multi-Audio Feature:</strong> Upload multiple audio files to create a memory that plays different recordings randomly when scanned! Perfect for capturing multiple moments or voices.
      </div>
    </div>
  </div>

  <div class="card">
    <!-- Hidden canvas for processing, user sees final result below -->
    <canvas id="preview" width="1200" height="360" class="hidden"></canvas>
    <p class="muted" id="meta" style="text-align: center; padding: 20px; margin: 0;"></p>
    <div id="result" class="hidden" style="margin-top:16px">
      <!-- Complete Memory Frame -->
      <div style="text-align: center;">
        <h4 style="margin: 0 0 16px 0; color: #0b0d12; font-size: 18px; font-weight: 600;">Your Complete Memory Frame</h4>
        <div style="border: 1px solid #e6e9f2; border-radius: 12px; padding: 16px; background: #fafbfc; margin-bottom: 16px;">
          <img id="waveformPreview" src="" alt="Complete memory composition" style="width: 100%; height: auto; border-radius: 8px; background: white; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"/>
        </div>
        <div style="display: flex; justify-content: center; gap: 12px; flex-wrap: wrap;">
          <button onclick="showImageModal()" class="btn-secondary btn-sm">View Full Size</button>
          <a id="imageLink" class="btn-secondary btn-sm" href="#" target="_blank" style="text-decoration: none;">Download Image</a>
          <a id="qrLink" class="btn-secondary btn-sm" href="#" target="_blank" style="text-decoration: none;">Play Audio</a>
        </div>
        <p style="margin: 16px 0 0 0; color: #6b7280; font-size: 13px; text-align: center;">
          This complete frame includes your title, waveform visualization, and QR code for audio playback
        </p>
      </div>
      
      <!-- Order Prints Section -->
      <div id="orderSection" class="hidden" style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #e6e9f2;">
        <h4 style="margin: 0 0 16px 0; color: #0b0d12; text-align: center;">Order Physical Prints</h4>
        <p style="margin: 0 0 20px 0; text-align: center; color: #6b7280; font-size: 14px;">
          Transform your MemoWindow into a beautiful physical frame with QR code
        </p>
        <div class="products-grid">
          <!-- Products will be loaded here -->
        </div>
      </div>
    </div>
  </div>

  <!-- User's Waveforms List -->
  <div id="waveformsList" class="card hidden">
    <h3 style="margin: 0 0 16px 0; color: #0b0d12;">Your MemoWindows</h3>
    <div id="waveformsContainer">
      <div class="muted" style="text-align: center; padding: 20px;">Loading your MemoWindows...</div>
    </div>
  </div>
</div>

<script>

    
const els = {
  file: document.getElementById('file'),
  fileUploadArea: document.getElementById('fileUploadArea'),
  fileUploadText: document.getElementById('fileUploadText'),
  titleInput: document.getElementById('titleInput'),
  btnCreate: document.getElementById('btnCreate'),
  status: document.getElementById('status'),
  preview: document.getElementById('preview'),
  meta: document.getElementById('meta'),
  result: document.getElementById('result'),
  imageLink: document.getElementById('imageLink'),
  qrLink: document.getElementById('qrLink'),
  waveformPreview: document.getElementById('waveformPreview'),
  orderSection: document.getElementById('orderSection'),
  // Auth elements
  authModal: document.getElementById('authModal'),
  mainContent: document.getElementById('mainContent'),
  userInfo: document.getElementById('userInfo'),
  btnLogin: document.getElementById('btnLogin'),
  btnLogout: document.getElementById('btnLogout'),
  userName: document.getElementById('userName'),
  userAvatar: document.getElementById('userAvatar'),
  ordersLink: document.getElementById('ordersLink'),
  // Email auth elements
  emailInput: document.getElementById('emailInput'),
  passwordInput: document.getElementById('passwordInput'),
  btnEmailLogin: document.getElementById('btnEmailLogin'),
  btnEmailRegister: document.getElementById('btnEmailRegister'),
  // Voice recorder elements
  btnRecord: document.getElementById('btnRecord'),
  recorderModal: document.getElementById('recorderModal'),
  startRecordBtn: document.getElementById('startRecordBtn'),
  stopRecordBtn: document.getElementById('stopRecordBtn'),
  playRecordBtn: document.getElementById('playRecordBtn'),
  recordingStatus: document.getElementById('recordingStatus'),
  recordingTimer: document.getElementById('recordingTimer'),
  recordedAudio: document.getElementById('recordedAudio'),
  useRecordingBtn: document.getElementById('useRecordingBtn'),
  cancelRecordingBtn: document.getElementById('cancelRecordingBtn'),
  // Waveforms list elements
  waveformsList: document.getElementById('waveformsList'),
  waveformsContainer: document.getElementById('waveformsContainer'),
};

const ctx = els.preview.getContext('2d');
let peaks = null;
let lastFile = null;

// Make peaks available globally for the auth module
window.peaks = null;

// Voice recording variables
let mediaRecorder;
let recordedChunks = [];
let recordingStartTime;
let recordingTimer;
let recordedBlob;

// Function to load user's waveforms with pagination support
async function loadUserWaveforms(offset = 0, append = false) {
  console.log('üîç loadUserWaveforms called with offset:', offset, 'append:', append);
  const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
  console.log('üîç Current user for waveforms:', currentUser?.displayName || currentUser?.email || 'No user');
  
  if (!currentUser) {
    console.log('üîç No user, hiding waveforms list');
    els.waveformsList.classList.add('hidden');
    return;
  }
  
  try {
    console.log('üîç Fetching waveforms...');
    const response = await fetch(`get_waveforms.php?user_id=${encodeURIComponent(currentUser.uid)}&offset=${offset}&limit=5`);
    console.log('üîç Response status:', response.status);
    
    if (!response.ok) throw new Error('Failed to load waveforms');
    
    const data = await response.json();
    console.log('üîç Raw response data:', data);
    
    // Handle pagination response format
    const waveforms = Array.isArray(data) ? data : (data.waveforms || []);
    const hasMore = data.has_more || false;
    const total = data.total || 0;
    
    console.log('üîç Waveforms received:', waveforms.length, 'items, hasMore:', hasMore, 'total:', total);
    console.log('üîç Waveforms data:', waveforms);
    
    if (append) {
      // Append to existing list
      appendWaveforms(waveforms, hasMore, total, offset);
    } else {
      // Replace entire list
      displayWaveforms(waveforms, hasMore, total, offset);
    }
    
    els.waveformsList.classList.remove('hidden');
    els.waveformsList.style.display = 'block';
    console.log('üîç Waveforms list should now be visible');
    
  } catch (error) {
    console.error('üîç Error loading waveforms:', error);
    els.waveformsContainer.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">Error loading waveforms</div>';
    els.waveformsList.classList.remove('hidden'); // Show the error message
  }
}

// Function to display waveforms in the list
function displayWaveforms(waveforms) {
  console.log('üîç displayWaveforms called with:', waveforms);
  console.log('üîç Waveforms container element:', els.waveformsContainer);
  
  if (!waveforms || waveforms.length === 0) {
    console.log('üîç No waveforms to display');
    els.waveformsContainer.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">No MemoWindows yet. Create your first one above!</div>';
    return;
  }
  
  console.log('üîç Generating HTML for', waveforms.length, 'waveforms');
  
  const waveformItems = waveforms.map(waveform => {
    const title = waveform.title || waveform.original_name || 'Untitled';
    const date = new Date(waveform.created_at).toLocaleDateString();
    const time = new Date(waveform.created_at).toLocaleTimeString();
    
    return `
      <div class="waveform-item" style="border: 1px solid #e6e9f2; border-radius: 8px; padding: 12px; margin-bottom: 8px; background: #fafbfc;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <strong style="color: #0b0d12;">${title}</strong>
            <div class="muted" style="font-size: 12px; margin-top: 2px;">
              ${waveform.original_name} ‚Ä¢ ${date} ${time}
            </div>
          </div>
          <div style="display: flex; gap: 8px;">
            <a href="${waveform.image_url}" target="_blank" class="btn-secondary btn-xs" style="text-decoration: none;">View</a>
            <a href="${waveform.qr_url}" target="_blank" class="btn-secondary btn-xs" style="text-decoration: none;">QR</a>
            <button onclick="deleteMemory(${waveform.id}, '${waveform.title.replace(/'/g, "\\'")}', this)" class="btn-danger btn-xs">Delete</button>
          </div>
        </div>
      </div>
    `;
  }).join('');
  
  els.waveformsContainer.innerHTML = waveformItems;
  
  // Add load more button if we received exactly 5 items (suggests there might be more)
  if (waveforms.length === 5) {
    const loadMoreBtn = document.createElement('div');
    loadMoreBtn.id = 'loadMoreBtn';
    loadMoreBtn.style.cssText = 'text-align: center; margin-top: 16px;';
    loadMoreBtn.innerHTML = `
      <button onclick="loadMoreMemories()" class="btn-secondary btn-sm">
        Load More
      </button>
    `;
    els.waveformsContainer.appendChild(loadMoreBtn);
  }
  
  // Set offset for load more
  window.currentWaveformsOffset = waveforms.length;
  
  console.log('üîç Waveforms HTML updated, offset set to:', window.currentWaveformsOffset);
}

// Make loadUserWaveforms available globally for the auth module
window.loadUserWaveforms = loadUserWaveforms;

// Function to delete a memory
async function deleteMemory(memoryId, title, buttonElement) {
  // Show confirmation dialog
  const confirmMessage = `Are you sure you want to delete "${title}"?\n\nThis will permanently remove:\n‚Ä¢ The waveform image\n‚Ä¢ The QR code\n‚Ä¢ The audio file\n‚Ä¢ All associated data\n\nThis action cannot be undone.`;
  
  if (!confirm(confirmMessage)) {
    return;
  }
  
  try {
    // Disable the delete button and show loading state
    buttonElement.disabled = true;
    buttonElement.textContent = 'Deleting...';
    buttonElement.style.background = '#6b7280';
    
    const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
    if (!currentUser) {
      throw new Error('Authentication required');
    }
    
    // Call delete endpoint
    const formData = new FormData();
    formData.append('memory_id', memoryId);
    formData.append('user_id', currentUser.uid);
    
    const response = await fetch('delete_memory.php', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || 'Delete failed');
    }
    
    const result = await response.json();
    
    if (result.success) {
      // Delete files from Firebase Storage if available
      if (window.deleteMemoryFiles && result.deleted_memory) {
        buttonElement.textContent = 'Deleting files...';
        
        // Get the memory data to find file URLs
        const waveforms = await fetch(`get_waveforms.php?user_id=${encodeURIComponent(currentUser.uid)}`);
        const allWaveforms = await waveforms.json();
        const memoryToDelete = allWaveforms.find(w => w.id == memoryId);
        
        if (memoryToDelete) {
          console.log('üóëÔ∏è Deleting Firebase Storage files...');
          const deleteResult = await window.deleteMemoryFiles(memoryToDelete.image_url, memoryToDelete.audio_url);
          console.log('üóëÔ∏è File deletion result:', deleteResult);
        }
      }
      
      // Remove the item from the list with animation
      const memoryItem = buttonElement.closest('.waveform-item');
      memoryItem.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
      memoryItem.style.opacity = '0';
      memoryItem.style.transform = 'translateX(-20px)';
      
      setTimeout(() => {
        memoryItem.remove();
        
        // Check if list is now empty
        const remainingItems = document.querySelectorAll('.waveform-item');
        if (remainingItems.length === 0) {
          els.waveformsContainer.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">No MemoWindows yet. Create your first one above!</div>';
        }
      }, 300);
      
      console.log('‚úÖ Memory and files deleted successfully');
    } else {
      throw new Error(result.error || 'Delete failed');
    }
    
  } catch (error) {
    console.error('Delete error:', error);
    alert('Failed to delete memory: ' + error.message);
    
    // Reset button state
    buttonElement.disabled = false;
    buttonElement.textContent = 'Delete';
    buttonElement.style.background = '#dc3545';
  }
}

// Make delete function available globally
window.deleteMemory = deleteMemory;

// Function to update create button state based on all requirements
function updateCreateButtonState() {
  const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
  const hasFile = lastFile && peaks;
  const hasTitle = els.titleInput.value.trim().length > 0;
  
  const shouldEnable = currentUser && hasFile && hasTitle;
  
  els.btnCreate.disabled = !shouldEnable;
  
  // Update status message to guide user
  if (!currentUser) {
    els.status.textContent = 'Please sign in to create memories';
  } else if (!hasFile) {
    els.status.textContent = 'Choose a voice recording to continue';
  } else if (!hasTitle) {
    els.status.textContent = 'Enter a memory title to continue';
  } else {
    els.status.textContent = 'Ready to create your memory!';
  }
  
}

// Make function available globally for auth module
window.updateCreateButtonState = updateCreateButtonState;

// Function to load order products for a memory
async function loadOrderProducts(memoryId, imageUrl) {
  console.log('loadOrderProducts called with:', memoryId, imageUrl);
  try {
    const response = await fetch('get_products.php');
    const products = await response.json();
    console.log('Products loaded:', products);
    
    const productsGrid = document.querySelector('.products-grid');
    console.log('Products grid element:', productsGrid);
    
    const productCards = products.map(product => `
      <div class="product-card" style="border: 1px solid #e6e9f2; border-radius: 12px; padding: 16px; background: white; text-align: center; display: flex; flex-direction: column; height: 280px;">
        <div style="background: #f8fafc; border-radius: 8px; padding: 16px; margin-bottom: 12px;">
          <div style="font-size: 24px; margin-bottom: 8px;">\ud83d\uddbc\ufe0f</div>
          <div style="font-weight: 600; color: #0b0d12; margin-bottom: 4px; font-size: 14px; line-height: 1.3;">${product.name}</div>
          <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">${product.size}</div>
          <div style="font-size: 12px; color: #6b7280;">${product.material}</div>
        </div>
        <div style="font-size: 18px; font-weight: 600; color: #0b0d12; margin-bottom: 8px;">${product.price_formatted}</div>
        <div style="font-size: 12px; color: #6b7280; margin-bottom: 16px; flex-grow: 1; display: flex; align-items: center; justify-content: center; line-height: 1.4;">${product.description}</div>
        <button onclick="orderProduct('${product.id}', ${memoryId}, '${imageUrl}')" 
                 class="btn-primary btn-full" style="margin-top: auto;">
            Order Now
          </button>
      </div>
    `).join('');
    
    productsGrid.innerHTML = productCards;
    els.orderSection.classList.remove('hidden');
    console.log('Order section should now be visible');
    
  } catch (error) {
    console.error('Error loading products:', error);
    els.orderSection.innerHTML = '<div style="text-align: center; color: #dc3545;">Error loading print options</div>';
    els.orderSection.classList.remove('hidden');
  }
}

// Function to initiate order process
async function orderProduct(productId, memoryId, imageUrl) {
  try {
    const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
    if (!currentUser) {
      return;
    }
    
    console.log('Creating order for:', { productId, memoryId, imageUrl });
    
    // Create Stripe checkout session
    const response = await fetch('create_checkout.php', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        product_id: productId,
        memory_id: memoryId,
        image_url: imageUrl,
        user_id: currentUser.uid,
        user_email: currentUser.email,
        user_name: currentUser.displayName || currentUser.email
      })
    });
    
    console.log('Checkout response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Checkout response error:', errorText);
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    
    const result = await response.json();
    console.log('Checkout result:', result);
    
    if (result.success && result.checkout_url) {
      // Redirect to Stripe checkout
      window.location.href = result.checkout_url;
    } else {
      alert('Error creating order: ' + (result.error || 'Unknown error'));
    }
    
  } catch (error) {
    console.error('Order error:', error);
    alert('Error placing order: ' + error.message);
  }
}

// Function to show order options for a specific memory
async function showOrderOptions(memoryId, imageUrl, title, buttonElement) {
  try {
    // Change button state to show loading
    const originalText = buttonElement.textContent;
    buttonElement.textContent = 'Loading...';
    buttonElement.disabled = true;
    
    // Create a modal-like overlay for product selection
    const orderModal = document.createElement('div');
    orderModal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    `;
    
    // Get products
    const response = await fetch('get_products.php');
    const products = await response.json();
    
    const modalContent = `
      <div style="background: white; border-radius: 20px; padding: 32px; max-width: 600px; width: 100%; max-height: 80vh; overflow-y: auto;">
        <div style="text-align: center; margin-bottom: 24px;">
          <h2 style="margin: 0 0 8px 0; color: #0b0d12;">Order Print for "${title}"</h2>
          <p style="margin: 0; color: #6b7280;">Choose your preferred print size and material</p>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 24px;">
          ${products.map(product => `
            <div class="product-card" style="border: 2px solid #e6e9f2; border-radius: 12px; padding: 16px; background: #fafbfc; text-align: center; transition: all 0.2s ease; cursor: pointer;" 
                 onclick="selectProduct('${product.id}', ${memoryId}, '${imageUrl}', this)">
              <div style="font-size: 32px; margin-bottom: 12px;">üñºÔ∏è</div>
              <div style="font-weight: 600; color: #0b0d12; margin-bottom: 4px; font-size: 14px;">${product.name}</div>
              <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">${product.size}</div>
              <div style="font-size: 12px; color: #6b7280; margin-bottom: 12px;">${product.material}</div>
              <div style="font-size: 18px; font-weight: 600; color: #2a4df5;">${product.price_formatted}</div>
              <div style="font-size: 11px; color: #6b7280; margin-top: 8px;">${product.description}</div>
            </div>
          `).join('')}
        </div>
        
        <div style="text-align: center;">
           <button onclick="closeOrderModal()" class="btn-secondary">
              Cancel
            </button>
        </div>
      </div>
    `;
    
    orderModal.innerHTML = modalContent;
    document.body.appendChild(orderModal);
    
    // Store reference for cleanup
    window.currentOrderModal = orderModal;
    
    // Reset button state
    buttonElement.textContent = originalText;
    buttonElement.disabled = false;
    
  } catch (error) {
    console.error('Error showing order options:', error);
    alert('Error loading order options: ' + error.message);
    
    // Reset button state
    buttonElement.textContent = originalText;
    buttonElement.disabled = false;
  }
}

// Function to select a product and proceed to checkout
async function selectProduct(productId, memoryId, imageUrl, cardElement) {
  // Visual feedback
  cardElement.style.borderColor = '#2a4df5';
  cardElement.style.background = '#f0f4ff';
  
  // Close modal and proceed to checkout
  closeOrderModal();
  
  // Start order process
  await orderProduct(productId, memoryId, imageUrl);
}

// Function to close order modal
function closeOrderModal() {
  if (window.currentOrderModal) {
    window.currentOrderModal.remove();
    window.currentOrderModal = null;
  }
}

// Function to show image in modal
function showImageModal() {
  const imageUrl = els.imageLink.href;
  if (!imageUrl || imageUrl === '#') {
    alert('No image available to display');
    return;
  }
  
  // Create modal overlay
  const modal = document.createElement('div');
  modal.className = 'image-modal';
  modal.onclick = (e) => {
    if (e.target === modal) closeImageModal();
  };
  
  modal.innerHTML = `
    <div class="image-modal-content">
      <button class="image-modal-close" onclick="closeImageModal()" title="Close">&times;</button>
      <img src="${imageUrl}" alt="Complete Memory Frame" style="max-width: 100%; max-height: 100%;">
    </div>
  `;
  
  document.body.appendChild(modal);
  window.currentImageModal = modal;
  
  // Add keyboard support
  document.addEventListener('keydown', handleImageModalKeydown);
}

// Function to close image modal
function closeImageModal() {
  if (window.currentImageModal) {
    window.currentImageModal.remove();
    window.currentImageModal = null;
    document.removeEventListener('keydown', handleImageModalKeydown);
  }
}

// Handle keyboard events for image modal
function handleImageModalKeydown(e) {
  if (e.key === 'Escape') {
    closeImageModal();
  }
}

// Function to load more memories
function loadMoreMemories() {
  const offset = window.currentWaveformsOffset || 0;
  console.log('üîç Load more clicked, current offset:', offset);
  
  // Call the auth module's loadUserWaveforms function directly
  const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
  if (!currentUser) {
    console.log('üîç No user for load more');
    return;
  }
  
  loadMoreWaveforms(offset);
}

// Function to load additional waveforms and append to list
async function loadMoreWaveforms(offset) {
  try {
    console.log('üîç Loading more waveforms from offset:', offset);
    const currentUser = window.getCurrentUser();
    const response = await fetch(`get_waveforms.php?user_id=${encodeURIComponent(currentUser.uid)}&offset=${offset}&limit=5`);
    
    if (!response.ok) throw new Error('Failed to load more waveforms');
    
    const data = await response.json();
    console.log('üîç Load more response:', data);
    
    const waveforms = Array.isArray(data) ? data : (data.waveforms || []);
    const hasMore = data.has_more || false;
    const total = data.total || 0;
    
    console.log('üîç Additional waveforms:', waveforms.length, 'hasMore:', hasMore);
    
    if (waveforms.length > 0) {
      // Generate HTML for additional waveforms
      const waveformItems = waveforms.map(waveform => {
        const title = waveform.title || waveform.original_name || 'Untitled';
        const date = new Date(waveform.created_at).toLocaleDateString();
        const time = new Date(waveform.created_at).toLocaleTimeString();
        
        return `
          <div class="waveform-item" style="border: 1px solid #e6e9f2; border-radius: 8px; padding: 12px; margin-bottom: 8px; background: #fafbfc;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <strong style="color: #0b0d12;">${title}</strong>
                <div class="muted" style="font-size: 12px; margin-top: 2px;">
                  ${waveform.original_name} ‚Ä¢ ${date} ${time}
                </div>
              </div>
              <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                <button onclick="showMemoryModal('${waveform.image_url}', '${title.replace(/'/g, "\\'")}', '${waveform.qr_url}')" class="btn-secondary btn-xs">View</button>
                <a href="${waveform.qr_url}" target="_blank" class="btn-secondary btn-xs" style="text-decoration: none;">QR</a>
                <button onclick="showOrderOptions(${waveform.id}, '${waveform.image_url}', '${title.replace(/'/g, "\\'")}', this)" class="btn-primary btn-xs">Order Print</button>
                <button onclick="deleteMemory(${waveform.id}, '${title.replace(/'/g, "\\'")}', this)" class="btn-danger btn-xs">Delete</button>
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      // Remove existing load more button
      const existingLoadMore = els.waveformsContainer.querySelector('#loadMoreBtn');
      if (existingLoadMore) {
        existingLoadMore.remove();
      }
      
      // Append new items
      els.waveformsContainer.insertAdjacentHTML('beforeend', waveformItems);
      
      // Add new load more button if there are more items
      if (hasMore) {
        const loadMoreBtn = document.createElement('div');
        loadMoreBtn.id = 'loadMoreBtn';
        loadMoreBtn.style.cssText = 'text-align: center; margin-top: 16px;';
        loadMoreBtn.innerHTML = `
          <button onclick="loadMoreMemories()" style="background: #6b7280; border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 500;">
            Load More (${total - offset - waveforms.length} remaining)
          </button>
        `;
        els.waveformsContainer.appendChild(loadMoreBtn);
      }
      
      // Update offset for next load more
      window.currentWaveformsOffset = offset + waveforms.length;
      console.log('üîç Updated offset to:', window.currentWaveformsOffset);
    }
    
  } catch (error) {
    console.error('üîç Error loading more waveforms:', error);
    alert('Error loading more memories: ' + error.message);
  }
}

// Function to show memory in modal (for list view button)
function showMemoryModal(imageUrl, title, qrUrl) {
  // Create modal overlay
  const modal = document.createElement('div');
  modal.className = 'image-modal';
  modal.onclick = (e) => {
    if (e.target === modal) closeImageModal();
  };
  
  modal.innerHTML = `
    <div class="image-modal-content">
      <button class="image-modal-close" onclick="closeImageModal()" title="Close">&times;</button>
      <div style="text-align: center; margin-bottom: 16px;">
        <h3 style="color: white; margin: 0 0 8px 0;">${title}</h3>
        <a href="${qrUrl}" target="_blank" style="color: #60a5fa; text-decoration: none; font-size: 14px;">üéµ Play Audio</a>
      </div>
      <img src="${imageUrl}" alt="Complete Memory Frame" style="max-width: 100%; max-height: 100%;">
    </div>
  `;
  
  document.body.appendChild(modal);
  window.currentImageModal = modal;
  
  // Add keyboard support
  document.addEventListener('keydown', handleImageModalKeydown);
}

// Voice Recording Functions
function openRecorderModal() {
  els.recorderModal.classList.remove('hidden');
  els.recorderModal.style.display = 'flex';
  resetRecorder();
  
  // Add escape key listener
  document.addEventListener('keydown', handleRecorderModalKeydown);
  
  // Add click outside to close
  els.recorderModal.addEventListener('click', handleRecorderModalClick);
}

function closeRecorderModal() {
  els.recorderModal.classList.add('hidden');
  els.recorderModal.style.display = 'none';
  stopRecording();
  resetRecorder();
  
  // Remove event listeners
  document.removeEventListener('keydown', handleRecorderModalKeydown);
  els.recorderModal.removeEventListener('click', handleRecorderModalClick);
}

function resetRecorder() {
  recordedChunks = [];
  recordedBlob = null;
  els.recordingTimer.textContent = '00:00';
  els.recordingStatus.innerHTML = '<span style="color: #6b7280;">Click record to begin</span>';
  els.startRecordBtn.disabled = false;
  els.stopRecordBtn.disabled = true;
  els.playRecordBtn.disabled = true;
  els.useRecordingBtn.disabled = true;
  els.recordedAudio.style.display = 'none';
  
  if (recordingTimer) {
    clearInterval(recordingTimer);
    recordingTimer = null;
  }
}

async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        sampleRate: 44100
      } 
    });
    
    mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'audio/webm;codecs=opus'
    });
    
    recordedChunks = [];
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      recordedBlob = new Blob(recordedChunks, { type: 'audio/webm' });
      const audioURL = URL.createObjectURL(recordedBlob);
      els.recordedAudio.src = audioURL;
      els.recordedAudio.style.display = 'block';
      els.playRecordBtn.disabled = false;
      els.useRecordingBtn.disabled = false;
      
      // Stop all tracks
      stream.getTracks().forEach(track => track.stop());
    };
    
    mediaRecorder.start(1000); // Collect data every second
    recordingStartTime = Date.now();
    
    // Update UI
    els.startRecordBtn.disabled = true;
    els.stopRecordBtn.disabled = false;
    els.recordingStatus.innerHTML = '<span class="recording-indicator">üî¥ Recording...</span>';
    
    // Start timer
    recordingTimer = setInterval(updateRecordingTimer, 100);
    
  } catch (error) {
    console.error('Recording failed:', error);
    alert('Recording failed: ' + error.message + '\n\nPlease make sure you have granted microphone permission.');
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
    els.startRecordBtn.disabled = false;
    els.stopRecordBtn.disabled = true;
    els.recordingStatus.innerHTML = '<span style="color: #059669;">‚úÖ Recording complete</span>';
    
    if (recordingTimer) {
      clearInterval(recordingTimer);
      recordingTimer = null;
    }
  }
}

function updateRecordingTimer() {
  if (recordingStartTime) {
    const elapsed = Date.now() - recordingStartTime;
    const seconds = Math.floor(elapsed / 1000) % 60;
    const minutes = Math.floor(elapsed / 60000);
    els.recordingTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }
}

function playRecording() {
  if (els.recordedAudio.paused) {
    els.recordedAudio.play();
    els.playRecordBtn.innerHTML = '‚è∏Ô∏è';
  } else {
    els.recordedAudio.pause();
    els.playRecordBtn.innerHTML = '‚ñ∂Ô∏è';
  }
}

function useRecording() {
  if (recordedBlob) {
    // Convert blob to File object
    const file = new File([recordedBlob], `recording_${Date.now()}.webm`, { 
      type: 'audio/webm',
      lastModified: Date.now() 
    });
    
    // Simulate file input selection
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(file);
    els.file.files = dataTransfer.files;
    
    // Update UI
    els.fileUploadArea.classList.add('has-file');
    els.fileUploadText.textContent = `üé§ ${file.name}`;
    
    // Process the recorded audio
    lastFile = file;
    processAudioFile(file);
    
    // Close recorder modal
    closeRecorderModal();
  }
}

async function processAudioFile(file) {
  try {
    els.meta.textContent = 'Processing recorded audio...';
    const buf = await decode(file);
    peaks = computePeaksFromBuffer(buf, 2000);
    window.peaks = peaks;
    els.meta.textContent = `Recorded: ${formatDuration(buf.duration)}`;
    drawPreview();
    updateCreateButtonState();
  } catch (error) {
    console.error('Audio processing failed:', error);
    els.meta.textContent = 'Error processing recorded audio';
  }
}

function formatDuration(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function handleRecorderModalKeydown(event) {
  if (event.key === 'Escape') {
    closeRecorderModal();
  }
}

function handleRecorderModalClick(event) {
  // Close modal if clicking on the backdrop (not the content)
  if (event.target === els.recorderModal) {
    closeRecorderModal();
  }
}

// Make recording functions available globally
window.openRecorderModal = openRecorderModal;
window.closeRecorderModal = closeRecorderModal;
window.startRecording = startRecording;
window.stopRecording = stopRecording;
window.playRecording = playRecording;
window.useRecording = useRecording;

// Make other functions available globally
window.loadOrderProducts = loadOrderProducts;
window.orderProduct = orderProduct;
window.showOrderOptions = showOrderOptions;
window.selectProduct = selectProduct;
window.closeOrderModal = closeOrderModal;
window.showImageModal = showImageModal;
window.closeImageModal = closeImageModal;
window.loadMoreMemories = loadMoreMemories;
window.showMemoryModal = showMemoryModal;


async function decode(file){
  const arrayBuf = await file.arrayBuffer();
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return await audioCtx.decodeAudioData(arrayBuf);
}

function computePeaksFromBuffer(buf, width=2000){
  const ch = buf.getChannelData(0);
  const hop = Math.max(1, Math.floor(buf.length / width));
  const min = new Float32Array(width), max = new Float32Array(width);
  for(let x=0;x<width;x++){
    const s=x*hop, e=Math.min((x+1)*hop, buf.length);
    let mi=1.0, ma=-1.0;
    for(let i=s;i<e;i++){ const v=ch[i]; if(v<mi) mi=v; if(v>ma) ma=v; }
    min[x]=mi; max[x]=ma;
  }
  return {min,max};
}

function drawPreview(){
  if(!peaks) return;
  
  // Keep canvas hidden during drawing - only show final result
  // els.preview.classList.remove('hidden');
  
  const W=els.preview.width,H=els.preview.height;
  ctx.clearRect(0,0,W,H);
  
  // Draw white background
  ctx.fillStyle='#fff'; 
  ctx.fillRect(0,0,W,H);
  
  // Get title from input
  const title = els.titleInput.value.trim() || 'Untitled Memory';
  
  // Calculate layout areas
  const titleHeight = 80;
  const qrSize = 120;
  const padding = 40;
  const waveformWidth = W * 0.7; // 70% of canvas width
  const waveformArea = {
    x: (W - waveformWidth) / 2, // Center the waveform
    y: titleHeight + padding,
    width: waveformWidth,
    height: H - titleHeight - qrSize - (padding * 3)
  };
  
  // Draw title at top center
  ctx.fillStyle = '#0b0d12';
  ctx.font = 'bold 32px system-ui, -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Word wrap title if too long
  const maxTitleWidth = W - (padding * 2);
  const words = title.split(' ');
  let line = '';
  let lines = [];
  
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    const testWidth = metrics.width;
    
    if (testWidth > maxTitleWidth && n > 0) {
      lines.push(line);
      line = words[n] + ' ';
    } else {
      line = testLine;
    }
  }
  lines.push(line);
  
  // Draw title lines
  const lineHeight = 40;
  const titleStartY = titleHeight / 2 - ((lines.length - 1) * lineHeight / 2);
  lines.forEach((line, index) => {
    ctx.fillText(line.trim(), W / 2, titleStartY + (index * lineHeight));
  });
  
  // Draw waveform in center area
  ctx.fillStyle = '#000';
  const waveformPad = waveformArea.height * 0.1;
  function yMap(v) { 
    return waveformArea.y + waveformArea.height - waveformPad - (v + 1) / 2 * (waveformArea.height - 2 * waveformPad); 
  }
  
  for(let x = 0; x < waveformArea.width; x++){
    const i = Math.floor(x * peaks.min.length / waveformArea.width);
    const y1 = yMap(peaks.max[i]);
    const y2 = yMap(peaks.min[i]);
    const lineWidth = Math.max(1, Math.floor(waveformArea.width / 800)); // Responsive line width
    ctx.fillRect(waveformArea.x + x, y1, lineWidth, Math.max(1, y2 - y1));
  }
  
  // Add QR code placeholder (will be replaced with actual QR when available)
  drawQRPlaceholder(padding, H - qrSize - padding, qrSize);
}

function drawQRPlaceholder(x, y, size) {
  // Draw QR placeholder
  ctx.fillStyle = '#f3f4f6';
  ctx.fillRect(x, y, size, size);
  ctx.strokeStyle = '#e5e7eb';
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, size, size);
  
  // QR placeholder text
  ctx.fillStyle = '#6b7280';
  ctx.font = '12px system-ui, -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('QR Code', x + size/2, y + size/2 - 8);
  ctx.fillText('(Generated after save)', x + size/2, y + size/2 + 8);
}

// Title input event listener to update button state and redraw preview
els.titleInput.addEventListener('input', () => {
  updateCreateButtonState();
  // Redraw preview with new title if waveform is loaded
  if (peaks) {
    drawPreview();
  }
});

// Voice recorder event listeners
els.btnRecord.addEventListener('click', openRecorderModal);
els.startRecordBtn.addEventListener('click', startRecording);
els.stopRecordBtn.addEventListener('click', stopRecording);
els.playRecordBtn.addEventListener('click', playRecording);
els.cancelRecordingBtn.addEventListener('click', closeRecorderModal);
els.useRecordingBtn.addEventListener('click', useRecording);

// Audio element event listeners
els.recordedAudio.addEventListener('ended', () => {
  els.playRecordBtn.innerHTML = '‚ñ∂Ô∏è';
});

els.recordedAudio.addEventListener('play', () => {
  els.playRecordBtn.innerHTML = '‚è∏Ô∏è';
});

els.recordedAudio.addEventListener('pause', () => {
  els.playRecordBtn.innerHTML = '‚ñ∂Ô∏è';
});

// File upload area uses label, so no manual click handler needed

// Multi-audio file selection handler
els.file.addEventListener('change', async (event)=>{
  const files = Array.from(els.file.files);
  
  if(files.length === 0) {
    // Reset upload area if no files
    els.fileUploadArea.classList.remove('has-file');
    els.fileUploadText.textContent = 'Upload Audio Files';
    document.getElementById('audioFilesList').style.display = 'none';
    lastFile = null;
    peaks = null;
    els.meta.textContent = '';
    return;
  }
  
  // Update upload area visual state
  els.fileUploadArea.classList.add('has-file');
  els.fileUploadText.textContent = `${files.length} file${files.length > 1 ? 's' : ''} selected`;
  
  // Display selected files
  displaySelectedAudioFiles(files);
  
  // Use the first file for waveform generation (for preview)
  const f = files[0];
  lastFile = f;
  els.meta.textContent = 'Decoding‚Ä¶';
  
  try {
    const buf = await decode(f);
    peaks = computePeaksFromBuffer(buf, 2000);
    window.peaks = peaks; // Make available to auth module
    els.meta.textContent = `Decoded ${f.name} (${files.length} file${files.length > 1 ? 's' : ''} total)`;
    drawPreview();
    
    // Check if create button should be enabled (user + file + title)
    updateCreateButtonState();
  } catch (error) {
    console.error('File processing failed:', error);
    els.meta.textContent = 'Error decoding audio file';
  }
});

// Display selected audio files with management options
function displaySelectedAudioFiles(files) {
  const container = document.getElementById('audioFilesContainer');
  const listContainer = document.getElementById('audioFilesList');
  
  container.innerHTML = '';
  
  files.forEach((file, index) => {
    const fileItem = document.createElement('div');
    fileItem.className = 'audio-file-item';
    fileItem.innerHTML = `
      <div class="audio-file-info">
        <svg class="audio-file-icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12,3V13.55C11.41,13.21 10.73,13 10,13A4,4 0 0,0 6,17A4,4 0 0,0 10,21A4,4 0 0,0 14,17V7H18V3H12Z"/>
        </svg>
        <div class="audio-file-details">
          <div class="audio-file-name">${file.name}</div>
          <div class="audio-file-size">${(file.size / 1024 / 1024).toFixed(1)} MB</div>
        </div>
      </div>
      <div class="audio-file-actions">
        <button class="play-audio-btn" id="playBtn_${index}" onclick="playAudioFile('${file.name}', ${index})">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
          </svg>
          Play
        </button>
        <button class="stop-audio-btn" id="stopBtn_${index}" onclick="stopAudioFile(${index})" style="display: none;">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
            <path d="M6,6H18V18H6V6Z"/>
          </svg>
          Stop
        </button>
        <button class="remove-audio-btn" onclick="removeAudioFile(${index})" title="Remove file">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
          </svg>
        </button>
      </div>
    `;
    container.appendChild(fileItem);
  });
  
  listContainer.style.display = 'block';
}

// Global variable to track currently playing audio
let currentPlayingAudio = null;
let currentPlayingIndex = -1;

// Play audio file preview
function playAudioFile(fileName, index) {
  const files = Array.from(els.file.files);
  const file = files[index];
  
  if (!file) return;
  
  // Stop any currently playing audio
  if (currentPlayingAudio) {
    stopAudioFile(currentPlayingIndex);
  }
  
  const audio = new Audio();
  const url = URL.createObjectURL(file);
  
  audio.src = url;
  
  // Store reference to current audio
  currentPlayingAudio = audio;
  currentPlayingIndex = index;
  
  // Update button states
  const playBtn = document.getElementById(`playBtn_${index}`);
  const stopBtn = document.getElementById(`stopBtn_${index}`);
  
  if (playBtn) playBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'flex';
  
  audio.play().catch(error => {
    console.error('Error playing audio:', error);
    alert('Could not play audio file. Please check if the file format is supported.');
    // Reset button states on error
    if (playBtn) playBtn.style.display = 'flex';
    if (stopBtn) stopBtn.style.display = 'none';
    currentPlayingAudio = null;
    currentPlayingIndex = -1;
  });
  
  // Handle audio end
  audio.addEventListener('ended', () => {
    URL.revokeObjectURL(url);
    // Reset button states
    if (playBtn) playBtn.style.display = 'flex';
    if (stopBtn) stopBtn.style.display = 'none';
    currentPlayingAudio = null;
    currentPlayingIndex = -1;
  });
  
  // Handle audio pause (if user pauses via browser controls)
  audio.addEventListener('pause', () => {
    if (playBtn) playBtn.style.display = 'flex';
    if (stopBtn) stopBtn.style.display = 'none';
    currentPlayingAudio = null;
    currentPlayingIndex = -1;
  });
}

// Stop audio file preview
function stopAudioFile(index) {
  if (currentPlayingAudio && currentPlayingIndex === index) {
    currentPlayingAudio.pause();
    currentPlayingAudio.currentTime = 0;
    currentPlayingAudio = null;
    currentPlayingIndex = -1;
    
    // Reset button states
    const playBtn = document.getElementById(`playBtn_${index}`);
    const stopBtn = document.getElementById(`stopBtn_${index}`);
    
    if (playBtn) playBtn.style.display = 'flex';
    if (stopBtn) stopBtn.style.display = 'none';
  }
}

// Remove audio file from selection
function removeAudioFile(index) {
  // Stop audio if this file is currently playing
  if (currentPlayingIndex === index) {
    stopAudioFile(index);
  }
  
  const files = Array.from(els.file.files);
  files.splice(index, 1);
  
  // Create new FileList-like object
  const dt = new DataTransfer();
  files.forEach(file => dt.items.add(file));
  els.file.files = dt.files;
  
  // Update display
  if (files.length === 0) {
    els.fileUploadArea.classList.remove('has-file');
    els.fileUploadText.textContent = 'Upload Audio Files';
    document.getElementById('audioFilesList').style.display = 'none';
    lastFile = null;
    peaks = null;
    els.meta.textContent = '';
  } else {
    displaySelectedAudioFiles(files);
    els.fileUploadText.textContent = `${files.length} file${files.length > 1 ? 's' : ''} selected`;
    
    // Update waveform with first file
    const f = files[0];
    lastFile = f;
    els.meta.textContent = 'Decoding‚Ä¶';
    
    decode(f).then(buf => {
      peaks = computePeaksFromBuffer(buf, 2000);
      window.peaks = peaks;
      els.meta.textContent = `Decoded ${f.name} (${files.length} file${files.length > 1 ? 's' : ''} total)`;
      drawPreview();
    }).catch(error => {
      console.error('Decode error:', error);
      els.meta.textContent = 'Error decoding audio file';
    });
  }
  
  // Update create button state
  updateCreateButtonState();
}

async function exportPngBlob(W=2000,H=600, qrCodeUrl=null){
  const tmp=document.createElement('canvas'); 
  tmp.width=W; 
  tmp.height=H; 
  const cx=tmp.getContext('2d');
  
  // Draw white background
  cx.fillStyle='#fff'; 
  cx.fillRect(0,0,W,H);
  
  // Get title
  const title = els.titleInput.value.trim() || 'Untitled Memory';
  
  // Calculate layout (same proportions as preview)
  const titleHeight = Math.floor(H * 0.13); // 13% for title
  const qrSize = Math.floor(H * 0.2); // 20% for QR code
  const padding = Math.floor(W * 0.02); // 2% padding
  const waveformWidth = W * 0.7; // 70% of canvas width (same as preview)
  const waveformArea = {
    x: (W - waveformWidth) / 2, // Center the waveform
    y: titleHeight + padding,
    width: waveformWidth,
    height: H - titleHeight - qrSize - (padding * 3)
  };
  
  // Draw title
  cx.fillStyle = '#0b0d12';
  const fontSize = Math.floor(W * 0.024); // Responsive font size
  cx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
  cx.textAlign = 'center';
  cx.textBaseline = 'middle';
  
  // Word wrap title
  const maxTitleWidth = W - (padding * 2);
  const words = title.split(' ');
  let line = '';
  let lines = [];
  
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = cx.measureText(testLine);
    const testWidth = metrics.width;
    
    if (testWidth > maxTitleWidth && n > 0) {
      lines.push(line);
      line = words[n] + ' ';
    } else {
      line = testLine;
    }
  }
  lines.push(line);
  
  // Draw title lines
  const lineHeight = fontSize * 1.2;
  const titleStartY = titleHeight / 2 - ((lines.length - 1) * lineHeight / 2);
  lines.forEach((line, index) => {
    cx.fillText(line.trim(), W / 2, titleStartY + (index * lineHeight));
  });
  
  // Draw waveform
  cx.fillStyle = '#000';
  const waveformPad = waveformArea.height * 0.1;
  function yMap(v) { 
    return waveformArea.y + waveformArea.height - waveformPad - (v + 1) / 2 * (waveformArea.height - 2 * waveformPad); 
  }
  
  for(let x = 0; x < waveformArea.width; x++){
    const i = Math.floor(x * peaks.min.length / waveformArea.width);
    const y1 = yMap(peaks.max[i]);
    const y2 = yMap(peaks.min[i]);
    const lineWidth = Math.max(1, Math.floor(waveformArea.width / 800)); // Responsive line width
    cx.fillRect(waveformArea.x + x, y1, lineWidth, Math.max(1, y2 - y1));
  }
  
  // Draw QR code if provided
  if (qrCodeUrl) {
    try {
      await drawQRCode(cx, padding, H - qrSize - padding, qrSize, qrCodeUrl);
    } catch (error) {
      console.error('Failed to draw QR code:', error);
      // Draw placeholder if QR fails
      drawQRPlaceholderOnCanvas(cx, padding, H - qrSize - padding, qrSize);
    }
  } else {
    drawQRPlaceholderOnCanvas(cx, padding, H - qrSize - padding, qrSize);
  }
  
  const dataURL=tmp.toDataURL('image/png');
  const byteString=atob(dataURL.split(',')[1]); 
  const ab=new ArrayBuffer(byteString.length); 
  const ia=new Uint8Array(ab);
  for(let i=0;i<byteString.length;i++){ ia[i]=byteString.charCodeAt(i); }
  return new Blob([ab],{type:'image/png'});
}

// Function to draw actual QR code on canvas
async function drawQRCode(ctx, x, y, size, qrUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      ctx.drawImage(img, x, y, size, size);
      resolve();
    };
    img.onerror = reject;
    img.src = qrUrl;
  });
}

// Function to draw QR placeholder on export canvas
function drawQRPlaceholderOnCanvas(ctx, x, y, size) {
  ctx.fillStyle = '#f3f4f6';
  ctx.fillRect(x, y, size, size);
  ctx.strokeStyle = '#e5e7eb';
  ctx.lineWidth = 3;
  ctx.strokeRect(x, y, size, size);
  
  ctx.fillStyle = '#6b7280';
  const fontSize = Math.floor(size * 0.08);
  ctx.font = `${fontSize}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('QR Code', x + size/2, y + size/2);
}

// Create button event listener
els.btnCreate.addEventListener('click', async (event)=>{
  event.preventDefault();
  
  const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
  
  const title = els.titleInput.value.trim();
  
  if(!lastFile||!peaks||!currentUser||!title) {
    const missingItems = [];
    if (!lastFile) missingItems.push('voice recording');
    if (!peaks) missingItems.push('waveform data');
    if (!currentUser) missingItems.push('user authentication');
    if (!title) missingItems.push('memory title');
    
    const message = `Missing: ${missingItems.join(', ')}`;
    els.status.textContent = message;
    return;
  }
  
  try{
    console.log('üîç Starting memory creation process...');
    els.status.textContent='Creating your memory‚Ä¶';
    
    // First create QR code URL
    const tempMemoryId = Date.now(); // Temporary ID for QR generation
    const tempPlayPageUrl = `${window.location.origin}${window.location.pathname.replace(/\/[^\/]*$/, '')}/play.php?temp_id=${tempMemoryId}`;
    const tempQrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=800x800&margin=1&data=${encodeURIComponent(tempPlayPageUrl)}`; // Higher resolution QR
    
    console.log('üîç Creating composition with QR:', tempQrApiUrl);
    // Create the complete composition with QR code at print resolution
    const blob = await exportPngBlob(3600, 2400, tempQrApiUrl); // 18x24 at 150 DPI
    console.log('üîç Composition blob created:', blob.size, 'bytes');

    els.status.textContent='Uploading, please wait...';
    
    // Use Firebase Storage instead of PHP upload
    if (!window.uploadWaveformFiles) {
      throw new Error('Firebase Storage not available');
    }
    
    // Upload all audio files
    console.log('üîç Uploading audio files...');
    const files = Array.from(els.file.files);
    const audioResults = [];
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      console.log(`üîç Uploading audio file ${i + 1}/${files.length}: ${file.name}`);
      
      const audioResult = await window.uploadWaveformFiles(null, file.name, currentUser.uid, file);
      console.log(`üîç Audio upload result ${i + 1}:`, audioResult);
      
      if (!audioResult.success) {
        throw new Error(audioResult.error || `Audio upload failed for ${file.name}`);
      }
      
      audioResults.push({
        audio_url: audioResult.audioUrl,
        original_filename: file.name,
        file_size: file.size,
        duration: null // Could be calculated if needed
      });
    }

    // Generate the final play page URL with a temporary ID (will update after DB save)
    const timestamp = Date.now();
    const baseName = lastFile.name.replace(/\.[^.]+$/, '');
    const uniqueId = timestamp + '_' + Math.random().toString(36).substr(2, 9);
    const finalPlayPageUrl = `${window.location.origin}${window.location.pathname.replace(/\/[^\/]*$/, '')}/play.php?uid=${uniqueId}`;
    
    // Generate QR code for the final composition
    els.status.textContent='Generating final composition‚Ä¶';
    const finalQrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=800x800&margin=1&data=${encodeURIComponent(finalPlayPageUrl)}`; // High resolution QR
    
    // Create the final complete composition with the actual QR code at print resolution
    const finalCompositionBlob = await exportPngBlob(3600, 2400, finalQrApiUrl); // 18x24 at 150 DPI
    
    // Upload the complete composition as the main image
    els.status.textContent='Uploading complete composition‚Ä¶';
    console.log('üîç Uploading composition blob...');
    const compositionResult = await window.uploadWaveformFiles(finalCompositionBlob, `${baseName}_composition.png`, currentUser.uid, null);
    console.log('üîç Composition upload result:', compositionResult);
    
    if (!compositionResult.success) {
      throw new Error(compositionResult.error || 'Composition upload failed');
    }

    // Use the composition as the main image URL
    const mainImageUrl = compositionResult.waveformUrl;
    const qrUrl = finalQrApiUrl;

    // Save metadata to database via PHP
    els.status.textContent='Saving metadata‚Ä¶';
    console.log('üîç Preparing database save...');
    
    const uploadData = {
      user_id: currentUser.uid,
      title: title,
      image_url: mainImageUrl, // Use the complete composition
      qr_url: qrUrl,
      unique_id: uniqueId,
      play_url: finalPlayPageUrl,
      audio_files: audioResults
    };

    console.log('üîç Sending data to upload_multi_audio.php:', uploadData);

    const res = await fetch('upload_multi_audio.php', {
      method: 'POST', 
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(uploadData)
    });
    console.log('üîç Upload response status:', res.status);
    
    if (!res.ok) {
      const errorText = await res.text();
      console.error('üîç Upload failed with response:', errorText);
      
      try {
        const errorData = JSON.parse(errorText);
        throw new Error(errorData.error || 'Metadata save failed');
      } catch (parseError) {
        throw new Error(`Upload failed (${res.status}): ${errorText}`);
      }
    }
    
    const responseText = await res.text();
    console.log('üîç Raw response:', responseText);
    
    try {
      const json = JSON.parse(responseText);
      console.log('üîç Parsed response:', json);
    } catch (parseError) {
      throw new Error('Invalid JSON response from server: ' + responseText);
    }
    
    const json = JSON.parse(responseText);

    els.status.textContent='Memory saved successfully!';
    els.result.classList.remove('hidden');
    
    // Set up the complete composition image
    els.imageLink.href = mainImageUrl;
    els.waveformPreview.src = mainImageUrl;
    
    // QR link should point to the play page  
    const actualPlayPageUrl = `${window.location.origin}${window.location.pathname.replace(/\/[^\/]*$/, '')}/play.php?id=${json.id}`;
    els.qrLink.href = actualPlayPageUrl;
    
    // QR code is now embedded in the complete composition, no separate display needed
    
    // Clear title input
    els.titleInput.value = '';
    
    // Show order section with products
    console.log('Loading order products for memory ID:', json.id);
    loadOrderProducts(json.id, result.waveformUrl);
    
    // Refresh the waveforms list
    await loadUserWaveforms();
    
  } catch(err) {
    console.error('Upload error:', err);
    els.status.textContent = 'Error: ' + err.message;
  }
});

</script>

<!-- Load the bundled Firebase authentication and styles -->
<link rel="stylesheet" href="dist/main.07cc2b43c659bd54da23.css">
<script type="module" src="firebase-config.php"></script>
<script src="dist/bundle.874b55151c9f182f3eeb.js"></script>
<script src="dist/bundle.0831caa59b61a8784be1.js"></script>

<script>
// Initialize app after Firebase bundle loads
window.addEventListener('load', () => {
  
  // Check for authentication errors in URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const error = urlParams.get('error');
  
  if (error) {
    let message = '';
    switch (error) {
      case 'access_denied':
        message = 'Access denied. Admin privileges required.';
        break;
      case 'login_required':
        message = 'Please sign in to access this page.';
        break;
      case 'database_error':
        message = 'Database connection error. Please try again.';
        break;
      case 'admin_required':
        message = 'Admin access required for this page.';
        break;
      default:
        message = 'Authentication error. Please sign in.';
    }
    
    // Show error message
    if (window.showMessage) {
      window.showMessage(message, 'error');
    } else {
      alert(message);
    }
    
    // Clear the error from URL
    const newUrl = window.location.pathname;
    window.history.replaceState({}, document.title, newUrl);
  }
  
  // Update button state for current user and loaded files
  if (window.updateCreateButtonState) {
    window.updateCreateButtonState();
  }
});
</script>
</body>
</html>
